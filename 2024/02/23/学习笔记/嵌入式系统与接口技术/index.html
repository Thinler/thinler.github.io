

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Thinler">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机组成CPU组成 ALU 运算器 二进制运算 CU 控制单元晶体管-&gt;逻辑门-&gt;加法器-&gt;ALU晶体管-&gt;存储器-&gt;锁存器…寄存器，…memory—&gt;RAM三态：高电压 低电压 高阻  冯·诺伊曼结构（普林斯顿结构） 指令程序和数据在同一个存储空间 哈佛结构指令、数据存在不同地方（双存储器） 计算机硬件结构ALU（Arithmetic Logical Uni">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式系统与接口技术">
<meta property="og:url" content="https://thinler.github.io/2024/02/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Thinler&#39;s Hexo Blog">
<meta property="og:description" content="计算机组成CPU组成 ALU 运算器 二进制运算 CU 控制单元晶体管-&gt;逻辑门-&gt;加法器-&gt;ALU晶体管-&gt;存储器-&gt;锁存器…寄存器，…memory—&gt;RAM三态：高电压 低电压 高阻  冯·诺伊曼结构（普林斯顿结构） 指令程序和数据在同一个存储空间 哈佛结构指令、数据存在不同地方（双存储器） 计算机硬件结构ALU（Arithmetic Logical Uni">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111428.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219112745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200951.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223201513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223202058.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240226100448.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240228110703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311104718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311105113.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313104418.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311104922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313114822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313170938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313172217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313201842.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202507.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202931.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240320102826.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322190525.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322190709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322194517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322195407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322195607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322200750.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322201620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322201836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202026.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322200910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202639.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202730.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202903.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322203018.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322203045.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-03-27_16-19-53.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240326223108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327100235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327102518.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327104020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327104938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327164505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-03-27_21-15-53.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-01_10-55-38.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-01_11-04-30.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240401111412.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240401112453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110240.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403111658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403111706.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407133236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-07_13-34-25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407133942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407134010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408180355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183830.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408184021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408190449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408200326.png">
<meta property="article:published_time" content="2024-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-08T12:20:08.057Z">
<meta property="article:author" content="Thinler">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111521.png">
  
  
  
  <title>嵌入式系统与接口技术 - Thinler&#39;s Hexo Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"thinler.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="嵌入式系统与接口技术"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-23 00:00" pubdate>
          2024年2月23日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          304 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">嵌入式系统与接口技术</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h3 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h3><ul>
<li>ALU 运算器 二进制运算</li>
<li>CU 控制单元<br>晶体管-&gt;逻辑门-&gt;加法器-&gt;ALU<br>晶体管-&gt;存储器-&gt;锁存器…寄存器，…memory—&gt;RAM<br>三态：高电压 低电压 高阻</li>
</ul>
<h3 id="冯·诺伊曼结构（普林斯顿结构）"><a href="#冯·诺伊曼结构（普林斯顿结构）" class="headerlink" title="冯·诺伊曼结构（普林斯顿结构）"></a>冯·诺伊曼结构（普林斯顿结构）</h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111521.png" srcset="/img/loading.gif" lazyload></p>
<p>指令程序和数据在同一个存储空间<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111420.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>指令、数据存在不同地方（双存储器）<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219111428.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="计算机硬件结构"><a href="#计算机硬件结构" class="headerlink" title="计算机硬件结构"></a>计算机硬件结构</h2><h3 id="ALU（Arithmetic-Logical-Unit）算术逻辑单元"><a href="#ALU（Arithmetic-Logical-Unit）算术逻辑单元" class="headerlink" title="ALU（Arithmetic Logical Unit）算术逻辑单元"></a>ALU（Arithmetic Logical Unit）算术逻辑单元</h3><p>算数、逻辑运算<br>双输入 单输出<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Pasted%20image%2020240219112745.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="存储器（读、写、访问）：容量（字、字节）、字长"><a href="#存储器（读、写、访问）：容量（字、字节）、字长" class="headerlink" title="存储器（读、写、访问）：容量（字、字节）、字长"></a><strong>存储器</strong>（读、写、访问）：容量（字、字节）、字长</h3><ul>
<li><p>位bit 0 or 1</p>
</li>
<li><p>字节byte 1byte&#x3D;8bit  所有存储器的基本存储数据单元 B</p>
</li>
<li><p>1kB &#x3D; 1024B；1MB &#x3D; 1024kB；1GB &#x3D; 1024MB；1TB &#x3D; 1024GB</p>
</li>
<li><p>字word 一次可以直接处理的二进制数码的位数，通常取决于微处理器内部通用寄存器的位数和<strong>数据总线的宽度</strong><br>（地址总线的宽度决定了CPU可以寻址的内存空间大小，而数据总线的宽度决定了CPU可以一次性传输数据的大小。）</p>
</li>
<li><p>if 数据总线是32位的，1word ↔ 32bit</p>
</li>
<li><p>字长反映并行运算能力 longer stronger</p>
</li>
<li><p>双字double word、四倍字quad word</p>
</li>
<li><p>字数——存储器的地址范围[地址的个数]，决定于所使用的地址总线位数</p>
</li>
<li><p>位数——存储器的数据范围[数据的宽度]，决定于所使用的数据总线位数</p>
</li>
</ul>
<p>不同字长存储器的地址安排<br>    16位时同一行两个字节地址的最低1位不同<br>    32位时同一行4个字节地址的最低2位不同</p>
<p>主存 RAM（随机存取 静态SRAM 动态DRAM）+ROM（只读）</p>
<ul>
<li>高速缓存 Cache CPU内部的小容量局部高速存储器</li>
<li>外存 磁盘 U盘 磁带等</li>
</ul>
<h3 id="控制器：指令、程序"><a href="#控制器：指令、程序" class="headerlink" title="控制器：指令、程序"></a><strong>控制器</strong>：指令、程序</h3><p>内部主要功能部件：</p>
<ul>
<li><strong>指令寄存器</strong>：存放由存储器取得的指令。</li>
<li><strong>译码器</strong>：将指令中的操作码翻译成控制信号。</li>
<li><strong>时序节拍发生器</strong>：产生时序脉冲节拍信号，使计算机有节奏、有次序地工作。</li>
<li><strong>操作控制部件</strong>：将控制信号组合起来，控制各个部件完成相应的操作。</li>
<li><strong>指令计数器</strong>：计算并指出下一条指令的地址。</li>
</ul>
<p>控制器对指令进行<strong>译码</strong>，并根据指令的操作要求指挥所有其它部件的工作，为此它根据指令生成一系列时序控制信号，控制其它单元工作。<br>控制器不断地从存储器中<strong>读取指令</strong>，然后分析指令的含义（译码），并执行指令的操作，执行完成以后又从存储器中读取下一条指令。</p>
<p>一条计算机指令的功能有限，完成复杂的运算功能需要将多条指令组合起来构成指令序列。这样一个完成某种功能的指令序列称为<strong>程序</strong>。</p>
<ul>
<li>通常还把CPU、存储器和输入&#x2F;输出接口电路和在一起构成的电路系统称为<strong>主机</strong>（也即微型计算机）</li>
</ul>
<h3 id="系统总线-各部件之间传送信息（BUS）"><a href="#系统总线-各部件之间传送信息（BUS）" class="headerlink" title="系统总线 各部件之间传送信息（BUS）"></a>系统<strong>总线</strong> 各部件之间传送信息（<strong>BUS</strong>）</h3><ul>
<li><p>地址总线 Address Bus<br>  CPU用来向存储器或I&#x2F;O端口传送地址 CPU单向发出<br>  位数n—&gt;可直接寻址的内存，IO接口容量$2^n$</p>
</li>
<li><p>数据总线 Data Bus<br>  CPU与存储器及外设交换数据的通路<br>  双向、三态<br>  位数与微处理器的位数相同</p>
</li>
<li><p>控制总线 Control Bus<br>  用来传输控制信号<br>  由两种方向的<strong>单向</strong>控制信号组成</p>
</li>
</ul>
<h3 id="总线：计算机中连接各个功能模块的纽带，是计算机各模块之间进行信息传输的公共线路。"><a href="#总线：计算机中连接各个功能模块的纽带，是计算机各模块之间进行信息传输的公共线路。" class="headerlink" title="总线：计算机中连接各个功能模块的纽带，是计算机各模块之间进行信息传输的公共线路。"></a><strong>总线</strong>：计算机中连接各个功能模块的纽带，是计算机各模块之间进行信息传输的<strong>公共线路</strong>。</h3><p>发射模块、接收模块<br>主设备：能启动总线服务的设备（如CPU）<br>从设备：只能等待启动命令的被动型设备</p>
<p> 按物理特性分类：<br>    - 电缆式：通常采用扁平电缆连接线路板<br>    - 主板式：在主机板上采用插槽方式供功能板插入。<br>    - 背板式：在机箱中设置一个专门的总线插槽板。</p>
<p> 按连线数量分类：<br>    - 串行总线：一条数据线进行数据传输<br>    - 并行总线：8位、16位、32位、64位</p>
<p> 按连接的对象分类：<br>    - 片总线：用于集成电路内部各功能单元的信息通路，属<strong>芯片级总线</strong><br>    - 系统总线（也称内总线）：用于计算机内部各插件板（部件）之间的互连，属板级总线。常用的总线标准有ISA、EISA、PCI、PCI-E等<br>    - 外总线：用于计算机之间或主机与外设之间的通信，属<strong>设备级总线</strong>。常用的总线标准有RS-232C、RS-485、IEEE-488、USB总线等</p>
<p> 数据传输方向<br>    - 单工：单向传输总线。<br>    - 双工：双向传输总线。<br>        - 半双工：只能在两个方向上轮流传输信息。<br>        - 全双工：可在两个方向上同时传输信息。</p>
<p>定时（时钟）特征</p>
<ul>
<li>同步：数据传输速率是固定的。</li>
<li>异步：数据传输速率是可变的</li>
</ul>
<h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a><strong>总线结构</strong></h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200600.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>各模块之间的信息传递都通过单总线进行。</li>
<li>优点：控制简单，易于扩充配置I&#x2F;O设备。</li>
<li>缺点：所有设备都连在一组总线上，总线只能分时工作，使数据传输量受限。</li>
</ul>
<h4 id="面向CPU的双总线结构"><a href="#面向CPU的双总线结构" class="headerlink" title="面向CPU的双总线结构"></a>面向CPU的双总线结构</h4><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200648.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>通过存储总线使CPU对主存进行读&#x2F;写操作。通过I&#x2F;O总线让CPU与I&#x2F;O设备进行数据交换。</li>
</ul>
<ul>
<li>优点：提高了微机系统数据传输效率。</li>
<li>缺点：外设和主存之间没有直接通路，要通过CPU进行信息交换，降低了CPU的工作效率。</li>
</ul>
<h4 id="面向主存的双总线结构"><a href="#面向主存的双总线结构" class="headerlink" title="面向主存的双总线结构"></a>面向主存的双总线结构</h4><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223200951.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>结合了以上2种结构的特点。提高了信息传送效率，同时也不降低CPU的工作效率。</p>
<h3 id="微机的性能指标"><a href="#微机的性能指标" class="headerlink" title="微机的性能指标"></a><strong>微机的性能指标</strong></h3><ul>
<li>主频：计算机的晶振频率，反映时钟周期的大小。</li>
<li>字长：CPU的数据位数，反映CPU并行处理能力。</li>
<li>内存容量：能存储信息的字节数。</li>
<li>存取周期：主存储器完成一次读写所需的时间。</li>
<li>响应时间：用户向计算机系统发出一个请求后，到系统对该请求做出响应并获得其结果所需的等待时间。</li>
<li>吞吐率：系统响应用户请求的速率。</li>
<li>运算速度：微机每秒所能执行的指令数。</li>
<li>MIPS（Million Instruction Per second)：反映计算机每秒可执行的指令数。</li>
</ul>
<h3 id="输入输出设备："><a href="#输入输出设备：" class="headerlink" title="输入输出设备："></a><strong>输入输出设备</strong>：</h3><p>基本输入输出方式：设备的编址、数据的传送方式</p>
<p>IO设备与CPU之间的连接：IO接口<br>     解决：速度、信号电平、信号格式、时序等不匹配问题</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223201513.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="统一编址法"><a href="#统一编址法" class="headerlink" title="统一编址法"></a>统一编址法</h4><ul>
<li>存储器映像的外设寻址</li>
<li>将接口中的控制寄存器、数据寄存器、状态寄存器和内存单元一样看待</li>
<li>接口与存储器采用不同的地址</li>
<li>可以利用访存指令进行输入输出操作</li>
</ul>
<h4 id="单独编址法"><a href="#单独编址法" class="headerlink" title="单独编址法"></a>单独编址法</h4><p>两个地址空间<br>访问存储器&#x2F;外围设备采用不同的指令</p>
<h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a><strong>中断方式</strong></h3><ul>
<li>中断——在发生了一个外部的事件时调用相应的处理程序的过程<br>  中断服务程序</li>
<li>中断服务程序与中断时CPU正在运行的程序是相互独立的，相互不传递数据。</li>
<li>中断处理中的问题<br>  设备识别方式<br>  中断处理程序入口地址的形成<br>  中断裁决<br>  中断屏蔽<br>  <img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240223202058.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>  多重中断</li>
<li>中断服务程序也可以被中断</li>
<li>中断嵌套<br>实现方法</li>
<li>给CPU及中断请求都设置优先级</li>
<li>多级中断</li>
</ul>
<p>嵌套中断响应过程：</p>
<ol>
<li>保存现场</li>
<li>关中断</li>
<li>识别中断</li>
<li>形成服务程序入口地址</li>
<li>执行服务程序<br> [可关中断阻止其他中断]<br> ……</li>
<li>恢复现场</li>
<li>开中断</li>
</ol>
<h2 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a><strong>计算机软件系统</strong></h2><ul>
<li>系统软件<ul>
<li>操作系统<ul>
<li>交互操作系统</li>
<li>实时操作系统</li>
<li>嵌入式操作系统 Embedded Operation System，EOS</li>
</ul>
</li>
<li>编译程序</li>
<li>解释程序</li>
</ul>
</li>
<li>应用软件</li>
<li>虚拟机 在实际硬件以上的机器层次都称为虚拟机，是由软件构成的外部特性</li>
</ul>
<h4 id="层次化结构"><a href="#层次化结构" class="headerlink" title="层次化结构"></a>层次化结构</h4><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240226100448.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><strong>Firmware</strong>：固定不变的常用软件固化在硬件中 （ROM） 成为<strong>固件</strong></p>
<h3 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a><strong>计算机语言</strong></h3><ul>
<li>机器语言 二进制代码</li>
<li>汇编语言 助记符</li>
<li>高级语言 与计算机结构无关 C等</li>
<li>应用语言 应用程序中使用 SQL HTML</li>
</ul>
<h3 id="定点数编码"><a href="#定点数编码" class="headerlink" title="定点数编码"></a><strong>定点数编码</strong></h3><h4 id="数制"><a href="#数制" class="headerlink" title="数制"></a><strong>数制</strong></h4><p>二进制——后缀B               1101.1010B<br>八进制——后缀Q或O        625.71Q<br>十进制——后缀D或省略    3.1415<br>十六进制——后缀H            0AE.3FH</p>
<p>$$<br>(𝑥)<em>{𝑁}&#x3D;𝑥_𝑛 𝑥</em>{𝑛−1}⋯𝑥<em>1 𝑥_0 𝑥</em>{−1}⋯𝑥_{−𝑚}&#x3D;∑_{𝑖&#x3D;−𝑚}^𝑛(𝑥_𝑖×𝑁^𝑖 )<br>$$</p>
<ul>
<li>定点数：小数点位置固定不变的数</li>
<li>定点整数：小数点定在最低位数的右面</li>
<li>定点小数：小数点固定在最高位数的后面，即纯小数表示</li>
</ul>
<p>0： 30h 48D<br>A：41h 65D<br>a： 61h  97D<br>回车(CR)：0DH<br>换行(LF)：0AH</p>
<p>计算机以二进制数的形式存储数据，称为机器数</p>
<ul>
<li>无符号数</li>
<li>有符号数<br>  原码、反码、补码、移码<br>  1位符号位</li>
</ul>
<h3 id="原码-Sign-magnitude-representation"><a href="#原码-Sign-magnitude-representation" class="headerlink" title="原码 (Sign-magnitude representation)"></a>原码 (Sign-magnitude representation)</h3><ul>
<li><strong>表示方法</strong>：原码使用二进制的最高位作为符号位（0代表正，1代表负），其余位</li>
<li>表示数值的绝对值。</li>
<li><strong>例子</strong>：+7 的原码为 0111，-7 的原码为 1111（假设使用4位表示）。</li>
</ul>
<h3 id="反码-Ones’-complement"><a href="#反码-Ones’-complement" class="headerlink" title="反码 (Ones’ complement)"></a>反码 (Ones’ complement)</h3><ul>
<li><strong>正数的反码</strong>与原码相同。</li>
<li><strong>负数的反码</strong>是对原码除符号位外的所有位取反（0变1，1变0）。</li>
<li><strong>例子</strong>：+7 的反码为 0111（与原码相同），-7 的反码为 1000（4位表示）。</li>
</ul>
<h3 id="补码-Twos’-complement"><a href="#补码-Twos’-complement" class="headerlink" title="补码 (Twos’ complement)"></a>补码 (Twos’ complement)</h3><ul>
<li><p><strong>正数的补码</strong>与原码相同。</p>
</li>
<li><p><strong>负数的补码</strong>是其反码加1。</p>
</li>
<li><p><strong>转换方法</strong>：无论正负数，将一个数的补码再次取补码可以得到其原码。</p>
</li>
<li><p><strong>例子</strong>：+7 的补码为 0111（与原码相同），-7 的补码为 1001（4位表示）。</p>
</li>
<li><p><strong>原码转反码和补码</strong>：</p>
<ul>
<li>正数：原码、反码、补码相同。</li>
<li>负数：反码是原码非符号位取反；补码是反码加1。</li>
</ul>
</li>
<li><p><strong>反码转原码</strong>：</p>
<ul>
<li>正数：直接转换。</li>
<li>负数：反码非符号位取反。</li>
</ul>
</li>
<li><p><strong>补码转原码</strong>：</p>
<ul>
<li>正数：直接转换。</li>
<li>负数：补码减1后，非符号位取反。<br><strong>移码</strong>：在补码基础上加$2^n$<br>-5    1011(补)    0011（移）</li>
</ul>
</li>
</ul>
<p>补码可直接相加、减<br>$$<br>[x]_补+[y]_补&#x3D;[x+y]_补<br>$$<br>$$<br>[x-y]_补&#x3D;[x]_补-y_补&#x3D;x_补+[-y]_补<br>$$<br><strong>字节存储顺序</strong> </p>
<ul>
<li>大数端(big Endian)：高位字节置于低地址，低位字节置于高地址 </li>
<li>小数端(little Endian)：低位字节置于低地址，高位字节置于高地址</li>
</ul>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>4H</td>
<td>00H</td>
</tr>
<tr>
<td>5H</td>
<td>11H</td>
</tr>
<tr>
<td>6H</td>
<td>AAH</td>
</tr>
<tr>
<td>7H</td>
<td>BBH</td>
</tr>
</tbody></table>
<p>小数端：BBAA1100H<br>大数端：0011AABBH<br>Intel,ARM均小端格式 摩托罗拉古早为大端</p>
<h3 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a><strong>浮点数编码</strong></h3><ul>
<li>组成：阶码E，尾数M，符号位S</li>
<li>E的编码：移码或补码<ul>
<li>移码：将数据的二进制编码加上一个常数（通常是 $2^{n-1}$）后的二进制代码作为该数据的编码。移码的特点：保持了数据原有的大小顺序，便于数据比较。</li>
</ul>
</li>
<li>S与M的编码：原码或补码</li>
</ul>
<table>
<thead>
<tr>
<th>S 符号位 0&#x2F;1</th>
<th>E 阶码 移码表示</th>
<th>M 尾数</th>
<th></th>
</tr>
</thead>
</table>
<p>$$<br>N&#x3D;(-1)^S\times M \times R^E<br>$$<br>R进制：多个二进制位构成一组，代表一个R进制位</p>
<h3 id="规范化浮点数（IEEE754）编码"><a href="#规范化浮点数（IEEE754）编码" class="headerlink" title="规范化浮点数（IEEE754）编码"></a><strong>规范化浮点数（IEEE754）编码</strong></h3><p>$$<br>N&#x3D;(-1)^S\times 1.M \times 2^e<br>$$<br>S and M :原码 S&#x3D;0为正<br>E&#x3D;e+127(单精度)        E&#x3D;e+1023(双精度)</p>
<ul>
<li>在单精度浮点数中，指数位偏移量为127。<ul>
<li>对于一个非负指数，真实指数值加上偏移量就是该指数的编码值</li>
<li>对于一个负指数，真实指数值加上偏移量的补码就是该指数的编码值。<br>单精度 32bit</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>S</th>
<th>E</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>31</td>
<td>30          (8)               23</td>
<td>22            (23)              0</td>
</tr>
</tbody></table>
<p>双精度 64bit</p>
<table>
<thead>
<tr>
<th>S</th>
<th>E</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>63</td>
<td>62            (11)              52</td>
<td>51            (52)              0</td>
</tr>
</tbody></table>
<h4 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a><strong>浮点数的表示范围</strong></h4><ul>
<li>浮点数的溢出表现为阶码的溢出。浮点数的上溢：数据太大，以至于大于阶码所能表示的数据；浮点数的下溢：数据太小，以至于小于阶码所能表示的数值</li>
<li>浮点数表示法可以扩大数值表示的范围；浮点数表示法未增加表示数值的个数；绝对值越大，浮点数分布越稀疏；</li>
<li>阶码位数越多，数据表示的<strong>范围</strong>就越大；尾数位数越多，数据表示的<strong>精度</strong>越高<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240228110703.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<h1 id="8086微机系统原理和结构"><a href="#8086微机系统原理和结构" class="headerlink" title="8086微机系统原理和结构"></a>8086微机系统原理和结构</h1><h2 id="8086-CPU特性"><a href="#8086-CPU特性" class="headerlink" title="8086 CPU特性"></a>8086 CPU特性</h2><ul>
<li>Intel公司于1977年推出</li>
<li>数据总线：16位</li>
</ul>
<ul>
<li>地址总线：20位</li>
</ul>
<ul>
<li>引脚功能复用</li>
<li>单总线、累加器结构</li>
</ul>
<ul>
<li>可控三态电路</li>
<li>总线分时复用</li>
</ul>
<h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a><strong>流水线技术</strong></h3><p>从8086&#x2F;8088开始，CPU采用了一种新的结构来并行地完成这些工作。执行单元负责执行指令，总线接口单元负责取指令、取操作数和写结果。它们独立地、并行地完成各自相应的工作。当EU执行指令时，BIU便“预取”下一条要执行的指令，所以大多数情况下取指令的时间可“省掉”，从而加快了程序的运行速度。这种结果称为流水线结构。</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311104718.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="寄存器结构"><a href="#寄存器结构" class="headerlink" title="寄存器结构"></a>寄存器结构</h2><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311105113.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>一般而言：寄存器数量越多，CPU功能越强</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a><strong>通用寄存器</strong></h3><p>16位 可将高8位 低8位分别作为两个独立的8位寄存器使用。</p>
<ol>
<li>AX：常用于存放算术逻辑运算中的操作数。所有的I&#x2F;O指令都使用累加器与外设接口传送信息。</li>
<li>BX：常用来存放访问内存时的基地址。</li>
<li>CX：在循环和<strong>串操作</strong>指令中用做计数器。</li>
<li>DX：在寄存器间接寻址的I&#x2F;O指令中存放I&#x2F;O端口的地址。</li>
<li>在做双字长乘&#x2F;除法运算时，DX与AX合起来存放一个双字长数(32位)，DX存放高16位，AX存放低16位。</li>
</ol>
<h3 id="指针和变址寄存器"><a href="#指针和变址寄存器" class="headerlink" title="指针和变址寄存器"></a><strong>指针和变址寄存器</strong></h3><p> <strong>SP</strong>：在堆栈操作中用来存放栈顶的偏移地址，永远指向堆栈的栈顶。<br><strong>BP</strong>：一般也常用来存放访问内存时的基地址，通常是与SS配对使用（BX通常是与DS配对使用）。<br><strong>SI、DI</strong>：常在<strong>变址寻址方式</strong>中作为索引指针。在字符串操作指令中，要求用SI作为源变址寄存器，存放源操作数的偏移地址；DI作为目标变址寄存器，存放目标操作数的偏移地址。</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a><strong>段寄存器</strong></h3><p><strong>CS</strong>: 代码段 内容是当前执行程序的指令代码段（的段基地址） 它和<strong>指令指针IP</strong>一起决定<strong>下一条</strong>所要执行指令的物理存储地址。<br><strong>DS</strong>: 数据段 存放数据字符（的段基地址）<br><strong>ES</strong>:附加段 在字符串操作时作为目标地址使用<br><strong>SS</strong>：堆栈段 用于存放需要保存的数据和地址。如在子程序调用或响应中断时保存返回主程序的地址和进入子程序后将要改变其值的寄存器的内容。</p>
<p>每一个存储单元的地址都是由它所在逻辑段的段基地址和段内的偏移地址两部分构成。</p>
<p>段基地址：逻辑段起始地址的高16位</p>
<p><em>堆栈的操作遵循先进后出的原则，操作的地址由SS(堆栈段基地址寄存器)和SP(堆栈指针寄存器)的内容指定。</em></p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a><strong>指令指针寄存器</strong></h3><p><strong>IP</strong>: 用来存放<strong>下一条</strong>要执行指令的&#x3D;&#x3D;偏移地址&#x3D;&#x3D;</p>
<p>当CPU从CS段偏移地址为(IP)的内存单元中取出指令代码的一个字节后，IP自动加1，指向指令代码的下一个字节。</p>
<p><strong>用户程序不能直接访问IP</strong> (指令的操作数不能是IP)。 </p>
<p>物理地址 &#x3D; 段地址 x 16 + 偏移地址<br>Physical Address&#x3D;(CS×16)+IP</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a><strong>标志寄存器</strong></h3><p>也称程序状态字（PSW），16位寄存器，但只使用了其中9位<br>6 个状态标志 + 3个控制标志</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313104418.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a><strong>状态标志</strong></h4><p>CF: 进位标志 有进&#x2F;借则1 无则0<br>PF: 运算结果低8位中1的个数 偶则PF&#x3D;1 奇则PF&#x3D;0<br>AF: $AF&#x3D;D_{3CY}$ 低四位向高四位有仅为或借位，则AF&#x3D;1，否则AF&#x3D;0 BCD运算则应调整<br>ZF: 当运算结果各位均为零时ZF&#x3D;1，否则ZF&#x3D;0<br>SF: $D_7&#x3D;1$(byte) or  $D_{15}&#x3D;1$(word) 则为1 反映符号位（负为1）<br>OF: 算术运算的结果超出了带符号数的范围，即溢出时OF&#x3D;1<br>    8位带符号数的范围是-128<del>+127，16位带符号数的范围是-32 768</del>+32 767。<br>$OF&#x3D;D_{7CY}\oplus D_{6CY}$ or $OF&#x3D;D_{15CY}\oplus D_{14CY}$<br>机器把所有数都当<strong>无符号数运算</strong>，把结果都当<strong>有符号数来设置标志</strong>。</p>
<p>无符号数加法 CF判断溢出<br>有符号数加法 OF判断溢出</p>
<ul>
<li>比较大小：<ul>
<li>对有符号数：<ul>
<li>无溢出时（OF&#x3D;0）：<ul>
<li>若 ZF&#x3D;1，则两数相等</li>
<li>若 ZF&#x3D;0 且 SF&#x3D;0，则被减数大</li>
<li>若 ZF&#x3D;0 且 SF&#x3D;1，则减数大</li>
</ul>
</li>
<li>有溢出时（OF&#x3D;1）：<ul>
<li>若 SF&#x3D;1，则被减数大</li>
<li>若 SF&#x3D;0，则减数大</li>
</ul>
</li>
</ul>
</li>
<li>对无符号数：<ul>
<li>若ZF&#x3D;1，则两数相等</li>
<li>若CF&#x3D;0，则被减数大</li>
<li>若CF&#x3D;1，则减数大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制标志"><a href="#控制标志" class="headerlink" title="控制标志"></a><strong>控制标志</strong></h4><p>控制CPU状态<br>DF: 控制字符串操作中地址的步进方向<br>    DF&#x3D;0 地址增址; DF&#x3D;1 地址减址<br>IF: IF&#x3D;1，允许CPU响应外部可屏蔽中断。IF&#x3D;0，禁止CPU响应外部可屏蔽中断。<br>TF: TF&#x3D;1，CPU处于<em>单步工作方式</em>，即CPU每执行一条指令就自动地发生一个内部中断，CPU转去执行一个中断程序，常用于程序调试，又称为<strong>陷井标志</strong>。TF&#x3D;0，CPU正常执行程序。 </p>
<h2 id="8086引脚定义及功能"><a href="#8086引脚定义及功能" class="headerlink" title="8086引脚定义及功能"></a>8086引脚定义及功能</h2><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240311104922.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>8086和8088都具有40条引出线、采用<strong>双列直插式封装</strong>的集成电路芯片。<br>8086的许多引脚都具有双重定义和功能，采用分时复用方式工作，即在不同时刻，引脚上的信号具有不同的意义。</p>
<ul>
<li>每根引脚只传送一种信息</li>
<li>引脚电平的高低代表不同的信号，如$M&#x2F;\overline{IO}$ ，在为低电平时，表示当前访问的是存储器；为高电平时，则表示访问输入&#x2F;输出接口。</li>
<li>在不同的时间范围，引脚传送不同的信息，即分时复用。如 $AD0\sim AD15$，在某一时刻传送地址的低16位信号；另一时刻则传送16位数据。</li>
<li>在引脚作为输入端或输出端时传送不同的信息。如$RQ&#x2F;\overline{GT_0}$ 端，作为输入端时，输入的是总线请求信号；为输出端时，则输出总线请求允许信号。</li>
<li>当CPU工作在不同模式时，引脚具有不同的名称和定义。8086微处理器有两种工作模式，<strong>最大模式</strong>和<strong>最小模式</strong>。两种工作模式下的引脚定义有一些区别，上图所示右边括号中的引脚名称就是CPU工作在最大模式时对应引脚的含义。</li>
</ul>
<h3 id="地址-数据总线"><a href="#地址-数据总线" class="headerlink" title="地址&#x2F;数据总线"></a><strong>地址&#x2F;数据总线</strong></h3><ul>
<li>20位地址线 16位数据线 分时复用 共同占用20根引脚</li>
<li>AD0~AD15地址、数据分时复用的双向信号线，三态。当 $ALE&#x3D;1$ 时，这些引脚上传输的是地址信号；当 $\overline{DEN}&#x3D;0$  时，这些引脚上传输的是数据信号。</li>
<li>A16<del>A19&#x2F;S3</del>S6 分时复用的地址&#x2F;状态信号线，三态输出。在8086访问存储器时，读&#x2F;写总线周期的第一个机器周期T1，从这4个引脚上送出最高4位地址A16<del>A19。而在总线周期的其他机器周期，这4个引脚送出状态信号S3</del>S6。这些状态信号里，S6始终为低电平；S5指示标志寄存器的中断允许标志位IP的状态；S4、S3的组合指示CPU当前正在使用的段寄存器。</li>
<li>CPU访问I&#x2F;O端口时 这四根引脚不适用，全为低电平。</li>
</ul>
<table>
<thead>
<tr>
<th>S4</th>
<th>S3</th>
<th>正在使用的段寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>ES</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>SS</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>CS or 未使用</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>DS</td>
</tr>
</tbody></table>
<h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a><strong>控制总线</strong></h3><ul>
<li><p>总共16根 2种工作模式共用的有8根</p>
</li>
<li><p>$MN&#x2F;\overline{MX}$工作方式控制输入。为高电平时，表示CPU工作在最小模式；为低电平时，表示CPU处于最大模式。</p>
</li>
<li><p>$\overline{RD}$ 读选通信号，三态，低电平有效。有效时，表示CPU正在对存储器或I&#x2F;O接口进行读操作。</p>
</li>
<li><p>$READY$ 高电平有效。有效时，表示存储器或I&#x2F;O设备已准备好，CPU可以进行数据传送。</p>
<ul>
<li>若存储器或I&#x2F;O设备未准备好，则READY信号为低电平。CPU在T3周期采样READY信号，若其为低电平，CPU自动插入等待周期Tw(1个或多个)，直到READY变为高电平后，CPU才脱离等待状态，完成数据传送过程。</li>
</ul>
</li>
<li><p>$INTR$ 可屏蔽中断请求输入信号，高电平有效。CPU在每条指令的最后一个周期采样该信号，以决定是否进入中断响应周期。可用软件屏蔽</p>
</li>
<li><p>$\overline{TEST}$ 测试信号输入引脚 低电平有效。当CPU执行WAIT指令时，每隔5个时钟周期对此引脚进行一次测试。若为高电平，CPU则继续处于空转状态进行等待，直到引脚变为低电平后，CPU才结束等待状态，继续执行下一条指令。</p>
</li>
<li><p>$NMI$ 非屏蔽中断请求输入信号，上升沿触发。这个引脚上的中断请求信号不能用软件屏蔽，CPU在当前指令执行结束后就进入中断过程。</p>
</li>
<li><p>$RESET$ 系统复位输入信号，高电平有效。为使CPU完成内部复位过程，该信号至少要在4个时钟周期内保持有效。当RESET返回低电平时，CPU将重新启动。</p>
</li>
<li><p>$\overline{BHE}&#x2F;S_7$ 分时复用的控制 &#x2F; 状态信号线，三态输出。在总线周期的第一个时钟周期输出 $\overline{BHE}$  信号，其他时钟周期输出状态信号 S7。$\overline{BHE}$信号的意义是：当$\overline{BHE}$ 为低电平时，表示可使用高 8 位数据线 AD8∼AD15；否则只使用低 8 位数据线 AD0~AD7。$\overline{BHE}$ 信号和地址信号一样需要锁存，它同最低位地址信号 A0 的状态组合在一起表示的功能见下表。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>$\overline{BHE}$</th>
<th>A0</th>
<th>使用的数据线</th>
</tr>
</thead>
<tbody><tr>
<td>读或写偶地址的一个字</td>
<td>0</td>
<td>0</td>
<td>AD15~AD0</td>
</tr>
<tr>
<td>读或写偶地址的一个字节</td>
<td>1</td>
<td>0</td>
<td>AD7~AD0</td>
</tr>
<tr>
<td>读或写奇地址的一个字节</td>
<td>0</td>
<td>1</td>
<td>AD15~AD8</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>1</td>
<td>1</td>
<td>无效</td>
</tr>
</tbody></table>
<h3 id="两种工作模式"><a href="#两种工作模式" class="headerlink" title="两种工作模式"></a><strong>两种工作模式</strong></h3><p><strong>最小模式</strong>：单微处理器模式，小系统所需全部控制信号都由CPU直接提供。<br><strong>最大模式</strong>：多微处理机模式，系统中除了有8086 CPU之外，还可接其他处理器构成多微处理器系统。<br>当$MN&#x2F;\overline{MX}&#x3D;1$ ：最小模式；<br>当$MN&#x2F;\overline{MX}&#x3D;0$：最大模式。<br>两种工作模式下的部分引脚具有不同的功能。<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313114822.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="最小模式"><a href="#最小模式" class="headerlink" title="最小模式"></a><strong>最小模式</strong></h3><ul>
<li> $\overline{INTA}$中断响应输出端。当 CPU 响应从 $\overline{INTA}$ 端输入的中断请求时，由 $\overline{INTA}$端输出两个连续的负脉冲，可用做外部中断源的中断向量码的读选通信号。</li>
<li>$ALE$ 地址锁存允许信号，三态输出，高电平有效。当它为高电平时，表明 CPU地址线上有有效地址。可利用它的下降沿将地址信号 $A0\sim A19$ 和 $\overline{BHE}$信号锁存到地址锁存器中。</li>
<li>$\overline{DEN}$数据允许信号，三态，低电平有效。该信号有效时，表示数据总线上有有效数据。它在每次访问内存或 I&#x2F;O 接口以及在中断响应期间有效。它常用做数据总线驱动器的片选信号。</li>
<li>$DT&#x2F;\overline{R}$数据传送方向控制信号，三态。用于确定数据传送的方向。高电平时，CPU 向存储器或 I&#x2F;O 端口发送数据；低电平时，CPU 从存储器或 I&#x2F;O 接口接收数据。此信号用于控制总线收发器的传送方向。</li>
<li>$M\overline{IO}$ 输入 &#x2F; 输出 &#x2F; 存储器控制信号，三态。用来区分当前操作是访问存储器还是访问 I&#x2F;O 端口。引脚输出为高电平时，表示访问存储器；为低电平时，则表示访问 I&#x2F;O 端口。</li>
<li>$\overline{WR}$写信号输出，三态。此引脚输出为低电平时，表示 CPU 正在对存储器或 I&#x2F;O 端口进行写操作。</li>
<li>HOLD 总线保持请求信号输入，高电平有效。当某一总线主控设备要占用系统总线时，通过此引脚向 CPU提出请求。</li>
<li>HLDA 总线保持响应信号输出，高电平有效。这是CPU 对 HOLD 请求的响应信号，当 CPU 收到有效的 HOLD 信号后，就会对其做出响应：一方面使 CPU 的所有三态输出的地址信号、数据信号和相应的控制信号变为高阻状态 ( 浮动状态 )；同时还输出一个有效的 HLDA，表示处理器现在已放弃对总线的控制。当 CPU 检测到 HOLD信号变低电平后，就立即使 HLDA变低电平，同时恢复对总线的控制。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313170938.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171021.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171137.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="8086存储器组织"><a href="#8086存储器组织" class="headerlink" title="8086存储器组织"></a>8086存储器组织</h2><p><strong>存储容量的表示</strong>：表示存放二进制代码的个数，用包含多少个存储单元，而每个单元又包含多少位来表示。微机中常以:字(节)数×字(节)的位数来表示，如:1024×8b-&gt;1K×8b-&gt;1KB<br><strong>字节数据</strong>：一个数存放一单元如:11H-&gt;00010H单元<br><strong>字数据</strong>：用二个连续单元存放，规定由2个单元中地址较小的一个确定。 “低对低、高对高”的存放规律(小数端)<br>**机器指令(机器码)**：按字节顺序存放<br>如：MOV  BX，AX     89C3H-&gt;00015H<br><strong>字符串</strong>：从低地址开始，以ASCII码顺序存放如：‘ABC’-&gt;00017H</p>
<h3 id="存储器访问"><a href="#存储器访问" class="headerlink" title="存储器访问"></a><strong>存储器访问</strong></h3><p><strong>奇</strong>地址存储器与数据总线<strong>高</strong>8位相连，<em><strong>偶</strong></em>地址存储器与数据总线<em><strong>低</strong></em>8位相连。（小端模式）<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313171934.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="存储器分段结构"><a href="#存储器分段结构" class="headerlink" title="存储器分段结构"></a><strong>存储器分段结构</strong></h3><ul>
<li><strong>分段管理</strong>：内部寄存器都是16位，不能直接输出20位地址。把1M分成许多个段，每一段最多可寻址216&#x3D;64K个单元。</li>
<li>规定每个段的基地址的<strong>低4位为0</strong>，即<strong>能被16整除</strong>。段地址和偏移地址都是16位无符号数，所以分段并不是唯一的，可以<strong>相互重迭</strong>。</li>
<li>CPU内部仅有四个段寄存器，所以在某个特定时刻仅能访问四个段。</li>
<li>8086&#x2F;8088存储器的分段结构：<strong>逻辑段</strong>长$2^{16}$&#x3D;64k字节<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313172217.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<p>每个存储单元都可用地址的两种形式来表示</p>
<ul>
<li>物理地址：用唯一的20位二进制数表示，CPU访问时用物理地址。</li>
<li>逻辑地址：段地址:偏移地址，程序中使用逻辑地址。如:03C0:0010<br>段基址(段起始地址)&#x3D;段地址&lt;&lt;4<br>20位物理地址&#x3D;段地址&lt;&lt;4+偏移地址</li>
</ul>
<table>
<thead>
<tr>
<th>内存访问类型</th>
<th>默认段寄存器</th>
<th>可指定段寄存器</th>
<th>段内偏移地址来源</th>
</tr>
</thead>
<tbody><tr>
<td>取指令</td>
<td>CS</td>
<td>无</td>
<td>IP</td>
</tr>
<tr>
<td>取栈操作</td>
<td>SS</td>
<td>无</td>
<td>SP</td>
</tr>
<tr>
<td>源串</td>
<td>DS</td>
<td>CS,ES,SS</td>
<td>SI</td>
</tr>
<tr>
<td>目的串</td>
<td>ES</td>
<td>无</td>
<td>DI</td>
</tr>
<tr>
<td>BP用作基址寻址</td>
<td>SS</td>
<td>CS,ES,DS</td>
<td>按寻址方式计算得到的有效地址</td>
</tr>
<tr>
<td>一般数据存取</td>
<td>DS</td>
<td>CS,ES,SS</td>
<td>按寻址方式计算得到的有效地址<br></td>
</tr>
</tbody></table>
<blockquote>
<p>Exx 某可执行程序长度为2kB，已知CS&#x3D;1063H，IP&#x3D;0000H，该程序的末地址(物理地址)为</p>
<p>末地址&#x3D;程序长度− 1&#x3D;2K − 1&#x3D;2048−1&#x3D;0800H − 1&#x3D;07FFH  末地址为:10630H+07FFH&#x3D;10E2FH</p>
</blockquote>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a><strong>数据存取</strong></h3><p><strong>数据对准</strong><br>当CPU读&#x2F;写一个字时，若字单元地址从偶地址开始，只需访问一次存储器；若字单元地址从奇地址开始，则需访问两次存储器。</p>
<p><strong>堆栈</strong><br>堆栈(STACK)是由若干个连续存储单元组成的、操作时遵循<strong>先进后出（FILO）</strong> 原则的一个存储器区，主要用于暂存中断和子程序调用时的现场数据及返回地址。（保护现场）</p>
<p>入栈和出栈都必须是**双字节数据(16位)**。进行一次入栈操作，SP减2；进行一次出栈操作，SP加2<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313201842.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="8086CPU时序"><a href="#8086CPU时序" class="headerlink" title="8086CPU时序"></a>8086CPU时序</h2><ul>
<li>微处理器是在统一的时钟信号CLK控制下，按照一定的<strong>时序</strong>来工作的。</li>
<li>8086时钟频率为5 MHz，一个时钟周期等于200 ns。</li>
<li>CPU的时序分为两种：<strong>时钟周期</strong>和<strong>总线周期</strong>。</li>
<li>8086CPU与内存或接口间的通信都是通过总线来进行的。通过总线对存储器或I／O接口进行一次访问所需的时间叫做一个<strong>总线周期</strong>，一个总线周期包括多个<strong>时钟周期</strong>。</li>
<li>CPU每执行一条指令至少要访问一次存储器(取指令)，即至少要进行一次读存储器操作，占用一个读总线周期。</li>
<li>一条<strong>指令</strong>的执行需要若干个总线周期才能完成。而一个总线周期又由若干个时钟周期构成。</li>
<li>每个时钟脉冲的持续时间就称为一个时钟周期。8086 CPU的一个读(或写)总线周期至少包括<strong>4个</strong>时钟周期。</li>
<li>时钟周期越短，CPU执行的速度就越快。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202201.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>8086 的数据总线和部分地址总线是分时复用的。在一个总线周期内，先利用总线传送地址，将地址锁存后，再利用同一总线传送数据。</li>
<li>8086 的数据总线和部分地址总线是分时复用的。在一个总线周期内，先利用总线传送地址，将地址锁存后，再利用同一总线传送数据。</li>
<li>在 T1 期间，BIU 部分将要访问的存储单元或输入&#x2F;输出端口地址送上总线<ul>
<li>若为读周期，则在第二个时钟周期将总线置为高阻缓冲状态，以使 CPU 有时间从输出地址方式转换为输人数据方式。之后在 T3 到 T4 期间从总线读入数据到 CPU</li>
<li>若为写周期，则 CPU 就不必转换工作方式，在地址锁存后直接输出数据到总线上。</li>
</ul>
</li>
<li>只有在指令流队列出现2个以上空单元时要填补指令流队列或在执行指令的过程中需要申请一个总线周期时，BIU 部分才会进入执行总线周期的状态。在两个总线周期之间，有时可能会出现一些总线上没有信息传送的时钟周期，此时的总线状态称为<strong>空闲状态</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202507.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>最小模式下工作时序</p>
<ul>
<li>在 T1 期间，地址&#x2F;状态复用信号线 A19&#x2F;S6<del>A16&#x2F;S3 和地址&#x2F;数据复用信号线 AD15</del>AD0 分别送出地址 A19<del>A16 和 A15</del>A0，与此同时送出地址锁存允许信号 ALE。$\overline{BHE}$的状态由 $\overline{BHE}&#x2F;S7$端输出。</li>
<li>外部电路在 T1 后期利用 ALE 的下降沿把地址信号锁存到地址锁存器中，从而在锁存器的输出端得到完整的 20 位地址信号 A19~A0。</li>
<li>读总线周期中，CPU 在 T3 到 T4 期间读入总线上的数据。在写总线周期中，CPU 从 T2 开始把数据送到总线上并维持到 T4。</li>
<li>某些情况下，当内存或接口的速度比较慢，使得在 4 个时钟周期里不能完成读&#x2F;写操作时，可通过时钟发生器产生一个低电平信号送到 8086 的 READY 端。8086 在每个总线周期的 T3 开始处都要检查 READY 的状态。若此时 READY 为低电平，则CPU不执行 T4，而是在 T3 之后插入一个等待时钟周期 Tw，以等待存储器或 I&#x2F;O 接口完成读&#x2F;写操作。</li>
<li>在 Tw 的开始时刻，CPU 还要检查 READY 状态，若仍为低电平，则再插入一个 Tw。</li>
<li>此过程一直进行到某个 Tw 开始时，READY 已经变为高电平，这时下一个时钟周期就是总线周期的最后一个时钟周期 T4。</li>
<li>利用 READY 信号，CPU可以插入若干个 Tw，使总线周期延长，达到可靠地读&#x2F;写内存和 I&#x2F;O 接口的目的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240313202931.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>最大模式下工作时序</p>
<h2 id="8086CPU寻址方式和指令系统"><a href="#8086CPU寻址方式和指令系统" class="headerlink" title="8086CPU寻址方式和指令系统"></a>8086CPU寻址方式和指令系统</h2><p>编程语言分：</p>
<ul>
<li>机器语言 二进制代码串</li>
<li>汇编语言 指令助记符、符号地址和标号等</li>
<li>高级语言</li>
</ul>
<h3 id="汇编语言程序开发过程："><a href="#汇编语言程序开发过程：" class="headerlink" title="汇编语言程序开发过程："></a><strong>汇编语言程序开发过程：</strong></h3><ol>
<li>编辑源程序生成*.ASM		EDIT         *.ASM</li>
<li>汇编生成目标程序*.OBJ：    	ML		  *.ASM； </li>
<li>连接生成可执行程序*.EXE：  LINK 	  *；</li>
<li>调试: 					DEBUG  	  *.EXE</li>
<li>执行：					可执行文件名</li>
</ol>
<h3 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a><strong>操作数寻址方式</strong></h3><p>寻址方式：指令中给出操作数的方法。</p>
<p>立即数操作数：       立即寻址<br>寄存器操作数：       寄存器寻址<br>存储器操作数：<br>    直接寻址<br>    寄存器间接寻址<br>    寄存器相对寻址<br>    基址变址寻址<br>    相对基址变址寻址</p>
<ol>
<li>立即寻址<br> 操作数以常数的形式直接表示在指令中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV AL,5      ;AL&lt;-5<br>MOV AX,1234H    ;AX&lt;-1234h<br>				;AH=12H,AL=34H<br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240320102826.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>立即数在内存的代码段内，指令执行时不需再存取存储器。<br><strong><em>不能</em>直接对段寄存器用立即数赋值</strong><br>立即数<strong>不能</strong>作目的操作数<br>给存储器操作数[默认段寄存器为DS]用立即数赋值时，要指明WORD PTR或者BYTE PTR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	BYTE PTR [300H], 5FH<br></code></pre></td></tr></table></figure>

<p>以A~F打头的数字出现在指令中时，前面要加数字0，以免与变量名等符号混淆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	BX, 0F77H<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>寄存器寻址<br>(1) 格式：操作数是通用寄存器或段寄存器中的内容。<br>  寄存器可以是通用寄存器（AX，BX，CX，DX，SP，BP，SI，DI， AH，AL，BH，BL，CH，CL，DH，DL）、段地址寄存器（ CS，SS，DS，ES）、标志寄存器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">INC CX		；CX&lt;-CX+1<br>MOV SS，AX	；SS&lt;-AX	<br>ADD CL，BH	；CL&lt;-CL+BH<br></code></pre></td></tr></table></figure>
<strong>注意点：</strong></li>
</ol>
<ul>
<li>操作数在CPU内的寄存器中，执行时间短；只访问寄存器，不访问内存</li>
<li><strong>CS一般不要求用户赋值</strong>。否则语法无错，执行错</li>
<li>两个操作数的长度必须一致</li>
</ul>
<p>操作数在内存中除代码段以外的存储区中。<br><strong>物理地址&#x3D;段寄存器&lt;&lt;4bit+EA</strong>（有效地址或偏移地址）<br>确定物理地址的关键：从指令中找出EA（由若干部分合成），再确定用哪个段寄存器。</p>
<ol start="3">
<li>直接寻址<br><strong>格式</strong>：操作数表示成[立即数]、[变量名]或变量名<br>MOV AX，[3000H]<br>MOV AX，VALUE	或MOV AX，[VALUE]<br>MOV AX，[VALUE+2]	或MOV AX，[VALUE]+2<br>也可指明段寄存器（称段超越）：<br>MOV AX，ES：[2000H]  ;“：”称修改属性运算符<br>MOV AX，CS：VALUE</li>
</ol>
<p>AX一般不用于间接寻址<br><strong>物理地址</strong>：<br>$$PA&#x3D;DS（或段超越指定的段寄存器）&lt;&lt;4+立即数或变量的偏移$$</p>
<ol start="4">
<li><p>寄存器间接寻址<br><strong>格式</strong>：操作数表示成[BX]、[BP]、[SI]或[DI]，寄存器内容是操作数的有效地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	BX，[DI]<br>MOV	[SI]，DS<br>MOV	[BP]，AX<br>MOV	ES：[DI]，AX<br>MOV	DX，DS：[BP]<br></code></pre></td></tr></table></figure>
</li>
<li><p>寄存器相对寻址<br><strong>格式</strong>：操作数表示成[BX&#x2F;BP&#x2F;SI&#x2F;DI+立即数&#x2F;变量名]，是直接寻址和寄存器间接寻址的组合。注意：变量的值是偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	BX，[SI+1003H]<br>MOV	AL，[DI+TABLE]	 <br>MOV	AL，TABLE[BX]	 <br>MOV	AL，[BP]+TABLE	 <br>MOV	BX，ES：[SI+1003H]<br>MOV	TABLE[BP]，AX<br></code></pre></td></tr></table></figure>
<p>物理地址：<br>$$<br>PA&#x3D;DS&lt;&lt;4+（BX&#x2F;SI&#x2F;DI）+立即数或变量的偏移<br>$$<br>$$<br>PA&#x3D;SS&lt;&lt;4+（BP）+立即数或变量的偏移</p>
</li>
</ol>
<p>$$</p>
<ol start="6">
<li><p>基址变址寻址<br>格式：操作数表示成[BX&#x2F;BP+SI&#x2F;DI]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	AX，[BX][DI]<br>MOV	CL，[BP+DI]<br>MOV	ES：[BX][SI]，AH	；或 MOV  [SI][BX]，AH<br></code></pre></td></tr></table></figure>
<p>物理地址：（段寄存器缺省的情况）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">PA=DS&lt;&lt;4+BX+SI/DI<br>PA=SS&lt;&lt;4+BP+SI/DI<br></code></pre></td></tr></table></figure>
</li>
<li><p>相对基址变址寻址<br> (1)  格式：操作数表示成[BX&#x2F;BP+SI&#x2F;DI+立即数&#x2F;变量名]</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV	AX，COUNT[BX][SI]<br>MOV	AX，COUNT[SI][BX]<br>MOV	AX，[BX+COUNT][SI]<br>MOV	AX，[BX+SI+COUNT]<br>MOV	AX，[BX]COUNT[SI]<br>ADD	VALUE[BX][DI]，DX；<br></code></pre></td></tr></table></figure>
<p>(2)  物理地址：（缺省情况）<br> PA&#x3D;DS&lt;&lt;4+BX+SI&#x2F;DI+立即数或变量的偏移<br> PA&#x3D;SS&lt;&lt;4+BP+SI&#x2F;DI +立即数或变量的偏移</p>
</li>
<li><p>I&#x2F;O端口寻址<br> 直接寻址：指令中直接给出8位端口地址，只能寻址256个端口<br> IN   AL&#x2F;AX，8位立即数(PORT)<br> OUT	8位立即数(PORT)，AL&#x2F;AX<br>间接寻址：将16位端口地址放入DX<br> MOV	DX，16位立即数<br> IN   	AL&#x2F;AX，DX<br> OUT	DX，AL&#x2F;AX<br> IN	           AL,	20H	; [20H]-&gt;AL<br> MOV	DX,	210H<br> OUT	DX,	AL	;AL-&gt;[210H]</p>
</li>
<li><p>隐含寻址<br>将一个操作数隐含在指令码中的寻址方式就称为隐含寻址。 </p>
<blockquote>
<p>例： 指令“MUL BL”的功能是把AL中的内容与BL中的内容相乘，乘积送到AX寄存器。即(AL)×(BL)→AX。这条指令隐含了被乘数AL及存放结果的累加器AX。</p>
</blockquote>
</li>
</ol>
<h3 id="转移地址寻址"><a href="#转移地址寻址" class="headerlink" title="转移地址寻址"></a><strong>转移地址寻址</strong></h3><ol>
<li>段内直接（相对）转移寻址<br>短转移：8位偏移<br>近转移：16位偏移</li>
</ol>
<p>（1）格式：操作码 	[SHORT 或NEAR PTR] 近标号。<br>    JMP	NEXT		；NEXT是一个短标号或近标号<br>    CALL	SUB		；SUB是一个段内子过程名<br>    在DEBUG中不能用标号和过程名：<br>    JMP	110H		;  执行CS:110处的指令<br>（2）转移的目标地址：<br>    CS不变；IP&#x3D;当前IP+指令中的8&#x2F;16位偏移量<br>（3）注意：条件转移只能段内直接短转移。</p>
<ol start="2">
<li>段内间接转移寻址：</li>
</ol>
<p>（1）格式：操作码	 16位通用寄存器操作数&#x2F;字类型存储器操作数<br>    JMP		BX<br>    JMP		AX<br>    JMP		SI<br>    JMP		TABLE[BX]		；TABLE是字变量<br>    JMP		WORD PTR[BP][DI]<br>    JMP		[BX]			；缺省表示是字</p>
<p>（2）转移的目标地址：<br>    CS不变；IP&#x3D;寄存器或连续2字节存储单元的内容</p>
<ol start="3">
<li><p>段间直接转移寻址：<br>(1) 格式：操作码	 [FAR PTR] 远标号<br> JMP		LABEL	；LABEL为远标号<br>(2) 转移的目标地址: CS&#x3D;标号的段地址；IP&#x3D;标号的偏移地址</p>
</li>
<li><p>段间间接转移寻址：<br>(1) 格式：操作码  FAR [PTR]或DWORD PTR  存储器操作数<br>    JMP		DWORD PTR[BP][SI]	<br>    JMP		VAR			；VAR是双字变量</p>
</li>
</ol>
<p>(2) 转移的目标地址：<br>     CS&#x3D;高2字节存储单元的内容；IP&#x3D;低2字节存储单元的内容。 </p>
<h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a><strong>指令介绍</strong></h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322190525.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a><strong>MOV</strong></h4><p>（1）格式：MOV	DST（目的操作数），SRC（源操作数）<br>（2）执行：DST&lt;-SRC<br>（3）操作数类型：立即数，寄存器操作数和存储器操作数</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322190709.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>使用 mov 指令读取内存时，只需提供偏移地址，而段地址是由 DS 寄存器提供的</li>
<li>8086CPU 不支持直接把数据放进段寄存器，对 DS 赋值需要用<strong>通用寄存器中转</strong>，比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx, 1000H<br>mov ds, bx<br></code></pre></td></tr></table></figure></li>
<li>两个操作数不能全为存储器</li>
<li>两个操作数不能全为段寄存器</li>
<li>DST不能是立即数</li>
<li>源和目的类型必须一致</li>
<li>MOV 不影响标志位</li>
<li>读写内存操作可以这样写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax, [0]<br>mov [0], cx<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="PUSH、POP"><a href="#PUSH、POP" class="headerlink" title="PUSH、POP"></a><strong>PUSH、POP</strong></h4><ul>
<li>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为$N(N≤64KB)$、地址连续、起始地址为16的倍数的内存单元当作栈空间来使用，从而定义了一个<strong>栈段</strong>。</li>
<li>栈底放在高地址处，栈顶在低地址处。</li>
<li>CPU 并不会知道我们将一段内存当作栈空间，CPU只认被 SS:SP 指向的内存单元中的值作为栈顶。</li>
<li>栈里的数据是16位的，占两个内存单元</li>
<li>push指令执行时，先将SP&#x3D;SP-2，再将要入栈的内容送入SS:SP指向的内存处，此时SS:SP指向新栈顶</li>
<li>pop指令执行时，先将SS:SP指向的数据送出，再SP&#x3D;SP+2，此时SS:SP指向新栈顶</li>
<li>8086CPU 不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何处，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执行的指令在何处，而不知道要执行的指令有多少。</li>
<li>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。</li>
<li>每次传送的数据为16位，16位数据在堆栈中的存放顺序按照“高高低低”原则。</li>
<li>用于保护数据：PUSH和POP指令保护和恢复寄存器和内存内容；CALL和RET或INT和IRET指令自动保护和恢复主程序断点处的段和偏移地址</li>
<li>不影响标志位。</li>
</ul>
<h4 id="XCHG"><a href="#XCHG" class="headerlink" title="XCHG"></a><strong>XCHG</strong></h4><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322194517.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>格式：XCHG	OPR1,OPR2（字节&#x2F;字）<br>执行：OPR1&lt;–&gt;OPR2</p>
<h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a><strong>Others</strong></h4><p><strong>LEA（取有效地址）</strong><br><strong>LDS、LES （将双字指针送寄存器和DS&#x2F;ES）</strong><br><strong>LAHF、SAHF（字节）</strong><br><strong>PUSHF、POPF（字）</strong> </p>
<h4 id="算数"><a href="#算数" class="headerlink" title="算数"></a><strong>算数</strong></h4><p>加法	&#x3D;&#x3D;ADD	ADC	INC&#x3D;&#x3D; 	DAA	AAA<br>减法	&#x3D;&#x3D;SUB	SUBB DEC	NEG	CMP&#x3D;&#x3D;  DAS	AAS<br>乘法	MUL	IMUL	AAM<br>除法	DIV	IDIV	CBW	CWD	AAD </p>
<p>上述指令基本上都影响标志位 </p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a><strong>逻辑</strong></h4><p>逻辑运算			AND	OR	XOR	NOT	TEST<br>移位	算术移位		SAL	SAR<br>    逻辑移位		SHL	SHR<br>    循环移位		ROL	ROR<br>    带借位的循环移位    RCL	RCR</p>
<h4 id="串操作"><a href="#串操作" class="headerlink" title="串操作"></a><strong>串操作</strong></h4><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a><strong>控制转移指令</strong></h3><p>无条件跳转      JMP<br>条件跳转         JZ&#x2F;JE  JNZ&#x2F;JNE  JS  JNS  JO  JNO  JP&#x2F;JPE  JNP&#x2F;JPO<br>(无符号数比较) JC&#x2F;JB&#x2F;JNAE  JNC&#x2F;JNB&#x2F;JAE  JBE&#x2F;JNA   JNBE&#x2F;JA<br>(有符号数比较) JL&#x2F;JNGE  JNL&#x2F;JGE  JLE&#x2F;JNG    JNLE&#x2F;JG   JCXZ<br>循环     	LOOP<br>过程调用和返回  CALL    RET<br>软件中断和返回  INT    IRET</p>
<p>（1）格式：	<br>     JMP  短标号&#x2F;近标号&#x2F;远标号&#x2F;字寄存器&#x2F;字存储器&#x2F;双字存储器<br>（2）不影响标志</p>
<p>例：JMP  SHORT LABEL ;段内直接转移<br>        JMP  BX ； 段内间接转移 ，IP←BX<br>        JMP  [BX]； 段内间接转移 ，IP←（BX）<br>        JMP  FAR PTR LABEL  ;段间间接转移<br>        JMP DWORD PTR [BX] ;段间间接转移 </p>
<h3 id="处理器控制"><a href="#处理器控制" class="headerlink" title="处理器控制"></a><strong>处理器控制</strong></h3><p>标志位操作 	CLC	 STC   CMC	CLD	STD	  CLI 	STI<br>空操作		NOP<br>外同步操作		HLT	ESC	WAIT	  LOCK	</p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a><strong>指令周期</strong></h3><p>8086指令的执行速率是由晶振控制产生的时钟决定的，每条指令执行都需要几个时钟周期。<br>8086CPU的工作频率5MHZ，一个时钟周期T&#x3D;1&#x2F;5MHZ&#x3D;0.2µs</p>
<h3 id="复杂指令系统计算机-CISC-和精简指令系统计算机-RISC"><a href="#复杂指令系统计算机-CISC-和精简指令系统计算机-RISC" class="headerlink" title="复杂指令系统计算机( CISC)和精简指令系统计算机 (RISC)"></a><strong>复杂指令系统计算机( CISC)和精简指令系统计算机 (RISC)</strong></h3><p>复杂指令系统计算机（CISC）<br>Complex Instruction Set Computer<br>指令系统复杂：指令数目大于200条，寻址方式多，指令格式多。<br>指令串行执行：执行步骤多，需要多个时钟周期。<br>各种指令都可访问存储器。<br>有较多专用寄存器。<br>编译程序难以进行高效的代码优化。</p>
<p>精简指令系统计算机（RISC）<br>Reduced Instruction Set Computer<br>简化的指令系统<br>以寄存器-寄存器方式工作<br>采用流水技术<br>使用较多的通用寄存器以减少访存<br>采用优化编译技术<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322195407.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="8086CPU的中断"><a href="#8086CPU的中断" class="headerlink" title="8086CPU的中断"></a>8086CPU的中断</h2><p><strong>中断的概念</strong><br>CPU在正常执行程序的过程中，由于某种原因，使CPU暂停当前程序的执行，转去处理临时发生的事件，处理完毕再返回继续执行暂停的程序。 ——该过程称中断<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322195607.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><p>8086CPU具有一个简单而灵活的中断系统，可处理256种不同的中断请求。</p>
</li>
<li><p>根据中断源是来自CPU内部还是<strong>外部</strong>，通常将所有中断源分为两类：外部中断源和内部中断源，对应的中断称为<strong>外部中断</strong>或<strong>内部中断</strong>。<br>  <strong>内部</strong><br>  INT  n 指令中断<br>  CPU执行INT  n 指令后，产生中断类型号N＝n 的中断；<strong>中断向量表地址＝4×n</strong><br>  例如：INT 21H，产生中断类型号为21H的中断，并从中断向量表的4×21H（即0:84H）单元取出中断服务程序的入口地址，转去执行<br>  除法错中断：除数为0或商超出寄存器范围。中断类型号N&#x3D;0<br>  溢出中断指令INTO：在算术运算指令之后紧跟INTO指令，可检查溢出标志OF 。中断类型号N＝4<br>  例如：测试加法的溢出<br>  MOV  AX,0009H               	MOV AX,9000H<br>  ADD AX,0080H                 	ADD AX,8000H<br>  INTO                                  	INTO<br>   ：                                      	：<br>  无溢出,不中断,顺序         溢出，中断，转移</p>
<p>  单步中断<br>  当标志位TF＝1时，每执行一条指令，CPU便产生中断类型号N＝1的单步中断。单步中断用于 Debug调试程序<br>  断点中断<br>  当程序设置了断点时，CPU执行到断点处便产生中断类型号N＝3的断点中断，并显示寄存器及单元内容，供Debug调试程序使用</p>
</li>
<li><p>外部中断中，通过可屏蔽中断请求引脚输入的中断请求信号称作<strong>可屏蔽中断</strong>请求，对这种中断请求CPU可响应，也可不响应，具体取决于标志寄存器中IF标志位的状态。通过<strong>不可屏蔽中断</strong>请求引脚输入的中断请求信号称作<strong>非屏蔽中断请求</strong>，这种中断请求CPU必须响应。<br>  <strong>非屏蔽</strong><br>  由引脚NMI引入，边沿触发，上升沿之后维持两个时钟周期高电平有效，中断类型号N＝2；不受中断标志位IF影响<br>  引起原因：RAM奇偶校验错误、I&#x2F;O通道扩展板奇偶校验错误、协处理器8087中断请求<br>  <strong>可屏蔽</strong><br>  引脚INTR引入，电平触发，高电平有效<br>  中断标志位<strong>IF＝1时允许中断；IF＝0时禁止中断</strong><br>  可用STI指令置位IF状态（开中断），CLI指令复位（关中断）<br>  引起原因：外部设备的中断请求</p>
</li>
<li><p><strong>硬件中断</strong>和<strong>软件中断</strong>是指引起中断的原因，硬件中断是由<strong>外设</strong>引发的，软件中断是执行<strong>中断指令</strong>产生的</p>
</li>
<li><p><strong>中断响应</strong>：CPU在每条指令的最后一个周期检测中断信号引脚，当条件满足时，CPU响应中断，向外设发中断响应信号，并保护断点，转向中断服务程序</p>
</li>
<li><p><strong>中断向量表</strong>：中断服务程序的入口地址存放处</p>
</li>
<li><p><strong>中断优先级</strong>：为了解决多个中断同时申请时响应的先后顺序问题，系统将所有的中断划分为四级，以0级为最高，依次降低，不同级别的中断同时申请时，CPU根据级别高低依次决定响应顺序。</p>
<ul>
<li>0 级——除单步中断以外的所有内部中断。</li>
<li>1 级——不可屏蔽中断。</li>
<li>2 级——可屏蔽中断。</li>
<li>3 级——单步中断。</li>
</ul>
</li>
<li><p>在实际系统中，常常遇到<strong>多个中断源</strong>同时请求中断的情况，这时 CPU 必须确定首先为哪一个中断源服务，以及服务的次序。解决的方法是排好中断处理的优先次序，即<strong>优先级</strong>，又称优先权。先响应优先级最高的中断请求。</p>
</li>
<li><p>另外，当 CPU 正在处理中断时，也要能响应优先级更高的中断请求，而屏蔽掉同级或较低级的中断请求即所谓<strong>多重中断</strong>的问题。</p>
</li>
</ul>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a><strong>中断处理过程</strong></h3><h4 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a><strong>可屏蔽中断</strong></h4><p>CPU响应<strong>可屏蔽中断</strong>的条件：</p>
<ul>
<li>外设提出中断申请</li>
<li>本中断位未被屏蔽</li>
<li>中断允许<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322200750.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<p>(1)  CPU响应可屏蔽中断<br>当中断接口电路中中断屏蔽触发器未被屏蔽时，外设可发出中断请求信号<br>CPU在每条指令的最后一个机器周期的最后一个T状态采样INTR引脚，若有中断请求信号且CPU内部中断允许触发器是开放的（IF＝1），则CPU响应中断<br>CPU向外设接口发两个中断响应信号INTA；外设收到第二个INTA，往数据线送中断类型号</p>
<p>(2)  CPU转入中断服务过程</p>
<ul>
<li>从数据总线读取由外设输入的中断类型号</li>
<li>标志寄存器PSW的值入栈；PSW中的中断允许标志IF和单步标志TF清0</li>
<li>保护断点，下一条指令的段地址CS和指令指针IP的值入栈</li>
<li>取中断向量表的中断入口地址，转入中断服务子程序；中断处理程序结束后，从堆栈依次弹出IP、CS和PSW，返回主程序断点处继续执行</li>
</ul>
<h4 id="非屏蔽中断请求NMI"><a href="#非屏蔽中断请求NMI" class="headerlink" title="非屏蔽中断请求NMI"></a><strong>非屏蔽中断请求NMI</strong></h4><p>CPU检测有NMI，不必判断IF标志，内部自动产生中断类型号N＝2，并转入相应中断服务过程</p>
<h4 id="软件（内部）中断INT-n"><a href="#软件（内部）中断INT-n" class="headerlink" title="软件（内部）中断INT  n"></a><strong>软件（内部）中断INT  n</strong></h4><p>由软件设定，不受IF标志影响，CPU内部形成中断类型号N＝n ，并转入相应中断服务过程<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322201620.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a><strong>中断向量表</strong></h3><p>也称中断服务程序入口地址表<br>中断向量表安排在内存的前1KB，即00000H~003FFH<br>每个服务程序入口地址CS:IP占用4个字节$(256*4＝1KB)$，高字节存放段地址CS，低字节存放段内偏移IP，按中断类型号顺序存放<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322201836.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>0～7-&gt;系统专用，<br>  8～FH-&gt;八级硬件中断，<br>    10H～1FH-&gt; BIOS调用，<br>      20H～3FH-&gt; DOS使用，<br>        40H～0FFH-&gt;可由用户程序使用。<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202026.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>(👆👆👆中断处理程序的STI可能是CLI)</p>
<h3 id="主程序的编程"><a href="#主程序的编程" class="headerlink" title="主程序的编程"></a><strong>主程序的编程</strong></h3><ol>
<li><p>主程序中的初始化<br>设置中断向量<br>设置8259A的中断屏蔽寄存器的中断屏蔽位<br>设置CPU中断允许位标志IF</p>
</li>
<li><p>硬件（外设接口）和CPU自动完成<br>外设向CPU INTR端发中断请求<br>执行完当前指令CPU发两个中断响应信号$\overline{INTA}$<br>CPU取中断类型号n<br>CPU将当前PSW、CS、IP入栈保护<br>清IF、TF，禁止外部中断和单步中断<br>从中断向量表取[4n]→IP，[4n＋2]→CS<br>转向中断服务子程序</p>
</li>
</ol>
<h3 id="中断服务子程序"><a href="#中断服务子程序" class="headerlink" title="中断服务子程序"></a><strong>中断服务子程序</strong></h3><p><strong>中断服务子程序的编写</strong></p>
<ul>
<li>保护现场，用PUSH指令将各寄存器值入栈</li>
<li>若允许中断嵌套，则用STI开中断（置IF＝1）</li>
<li>执行中断处理程序</li>
<li>用CLI关中断（清IF＝0）</li>
<li>给中断命令寄存器送中断结束命令EOI【仅针对8259】</li>
<li>恢复现场，用POP指令将各寄存器值退栈恢复</li>
<li>用中断返回指令IRET返回主程序</li>
</ul>
<h3 id="中断响应时序"><a href="#中断响应时序" class="headerlink" title="中断响应时序"></a><strong>中断响应时序</strong></h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322200910.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="中断优先级和中断嵌套"><a href="#中断优先级和中断嵌套" class="headerlink" title="中断优先级和中断嵌套"></a><strong>中断优先级和中断嵌套</strong></h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202552.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>多中断源的中断流程增加了<strong>屏蔽本级和低级中断</strong>和<strong>开中断</strong>以允许嵌套<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202639.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="软件查询确定中断优先级"><a href="#软件查询确定中断优先级" class="headerlink" title="软件查询确定中断优先级"></a><strong>软件查询确定中断优先级</strong></h4><p>软件查询中断方式，是将各个外设的中断请求信号通过或门后，送到 CPU 的 INTR 端，同时把几个外设的中断请求状态位组成一个端口，赋以<strong>端口号</strong>，如下图所示。任一外设有中断请求，CPU 响应中断后进入中断处理子程序，用软件读取端口内容，<strong>逐位查询端口</strong>的每位状态，查到哪个外设有请求中断，就转入哪个外设的中断服务程序。查询程序的次序，决定了外设优先级别的高低，先测试的中断源优先级别最高。当然在软件查询程序中也可用移位或屏蔽法来改变端口各位的测试次序，但查询时间较长，对中断源较多的情况不合适。<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202730.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="硬件查询确定优先级——菊花链法"><a href="#硬件查询确定优先级——菊花链法" class="headerlink" title="硬件查询确定优先级——菊花链法"></a><strong>硬件查询确定优先级——菊花链法</strong></h4><p>越靠近CPU的外设，优先级越高<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202903.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322202945.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="矢量中断优先级"><a href="#矢量中断优先级" class="headerlink" title="矢量中断优先级"></a><strong>矢量中断优先级</strong></h4><p>由优先级管理逻辑判别最高优先级中断请求<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322203018.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a><strong>中断嵌套</strong></h4><p>高优先级的中断源能中断低优先级的中断处理<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240322203045.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="中断实验编程说明"><a href="#中断实验编程说明" class="headerlink" title="中断实验编程说明"></a><strong>中断实验编程说明</strong></h3><ol>
<li>中断初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV  BL, IRQNum; 	取得中断矢量号<br>CALL INT_INIT; 	初始化中断向量表<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">INT_INIT   PROC [FAR]	;FAR可省略<br>CLI<br>MOV AX, 0<br>MOV ES, AX<br>XOR BH, BH<br>SHL BX, 1<br>SHL BX, 1<br>MOV AX, OFFSET MYIRQ<br>MOV ES:[BX], AX<br>MOV AX, SEG MYIRQ<br>MOV ES:[BX+2], AX<br>RET<br>INT_INIT   ENDP<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>中端服务程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">LEDON	   DB	00000001b<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">MYIRQ 	PROC [FAR]<br>		PUSH DX<br>		PUSH AX<br>; 读取C口数值，并把LEDON的值输出到PC7。<br>		MOV	DX, L8255PC	; DX指向C端口<br>		IN  AL, DX		; 读取C口数值<br>		AND AL, 01111111b	; 清除PC7<br>		XOR	[LEDON], 00000001b    ; LED灯状态取反<br>		JZ  ISROut<br>		OR  AL, 10000000b	; 置位PC7<br>ISROut:	OUT DX, AL	; 更新PC端口<br>		POP AX<br>		POP DX	; 取回DX	<br>		IRET<br>MYIRQ 	ENDP<br></code></pre></td></tr></table></figure>

<h1 id="8086汇编语言程序设计"><a href="#8086汇编语言程序设计" class="headerlink" title="8086汇编语言程序设计"></a>8086汇编语言程序设计</h1><h2 id="汇编语言程序格式"><a href="#汇编语言程序格式" class="headerlink" title="汇编语言程序格式"></a>汇编语言程序格式</h2><ol>
<li>两种汇编程序开发模板<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">	.MODEL  SMALL<br>	.8086<br>	.data<br>DA1  DB &#x27;Welcome to this course!&#x27;,0DH,0AH <br>          DB &#x27;This is a sample program.&#x27;,&#x27;$&#x27;<br>	.stack 100h<br>	.code<br>	.startup  	;初始化指令<br>	MOV AH,9  	;DOS 9号功能调用<br>         	MOV DX,OFFSET DA1<br>         	INT 21H<br>	.EXIT 0  ;程序结束，形成返回DOS指令<br>	END<br><br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>.MODEL SMALL</code> 指定了程序的内存模型为小型，适用于小型程序。</li>
<li><code>.8086</code> 指定了程序目标处理器为8086。</li>
<li><code>.data</code> 段定义了要显示的字符串数据。</li>
<li><code>.stack 100h</code> 指定了堆栈段的大小为256字节。</li>
<li><code>.code</code> 段包含了程序的主要执行代码。</li>
<li><code>.startup</code> 是一个宏指令，用于初始化程序。</li>
<li><code>MOV AH,9</code> 和 <code>MOV DX,OFFSET DA1</code> 准备了DOS的9号功能调用，用于显示字符串。</li>
<li><code>INT 21H</code> 执行DOS调用。</li>
<li><code>.EXIT 0</code> 结束程序并返回DOS。</li>
<li><code>END</code> 指示程序结束。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">DATA SEGMENT ;数据段<br>DA1  DB &#x27;Welcome to this course!&#x27;,0DH,0AH <br>          DB &#x27;This is a sample program.&#x27;,&#x27;$&#x27;<br>DATA ENDS ;数据段结束<br>STACK SEGMENT ;堆栈段<br>ST1  DB 100 DUP(?) ;在数据段中定义一个名为 `ST1` 的数组，该数组包含100个字节，每个字节的初始值都是括号内的内容<br>STACK   ENDS ;堆栈段结束<br>CODE SEGMENT ;代码段<br>ASSUME CS:CODE,DS:DATA,SS:STACK<br>MAIN PROC  FAR<br>START: MOV AX,STACK ;送堆栈段段地址<br>         MOV SS,AX<br>         PUSH DS ;返回DOS用<br>         MOV AX,0<br>         PUSH AX<br>         MOV AX,DATA ;送数据段段地址<br>         MOV DS,AX<br>         MOV AH,9  ;DOS 9号功能调用<br>         MOV DX,OFFSET DA1<br>         INT 21H<br>         RET<br>MAIN   ENDP<br>CODE ENDS ;代码段结束<br>END START ;程序结束<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>DATA SEGMENT</code> 开始数据段，定义了要显示的字符串数据。在8086汇编语言中，<code>SEGMENT</code> 和 <code>ENDS</code> 指令用于定义一个段的开始和结束。<code>DB</code> 指令用于定义字节型数据，意味着“Define Byte”。在这里，<code>DB</code> 后面跟着的是要存储的字符串 <code>&#39;Welcome to this course!&#39;</code>，后面紧跟两个特殊字符 <code>0DH</code> 和 <code>0AH</code>。</li>
<li>另一个字符串 <code>&#39;This is a sample program.&#39;</code>，并在字符串的末尾添加了一个 <code>&#39;$&#39;</code> 字符。在DOS中断调用中，<code>&#39;$&#39;</code> 被用作字符串的结束标志，特别是在使用DOS的9号功能调用（即显示字符串）时。这意味着当DOS遇到 <code>&#39;$&#39;</code> 字符时，它知道字符串已经结束，不会继续读取更多的数据。</li>
<li><code>&#39;Welcome to this course!&#39;</code> 是一个字符串常量，存储在数据段中。</li>
<li><code>0DH</code> 和 <code>0AH</code> 是两个十六进制数，分别代表回车（Carriage Return, CR）和换行（Line Feed, LF）字符。在DOS和Windows系统中，这两个字符组合用来表示新的一行的开始。在ASCII码中，<code>0D</code> 对应13（CR），<code>0A</code> 对应10（LF）。</li>
<li><code>STACK SEGMENT</code> 定义了堆栈段，为堆栈预留了100字节的空间。</li>
<li><code>CODE SEGMENT</code> 开始代码段，包含程序的主要执行代码。</li>
<li><code>ASSUME</code> 指令关联了段寄存器和相应的段。</li>
<li><code>MAIN PROC FAR</code> 定义了一个远过程。</li>
<li><code>MOV AX,STACK</code> 和后续指令初始化堆栈。</li>
<li><code>MOV AX,DATA</code> 和后续指令设置数据段地址。</li>
<li><code>MOV AH,9</code> 和 <code>MOV DX,OFFSET DA1</code> 准备DOS的9号功能调用。</li>
<li><code>INT 21H</code> 执行DOS调用。<code>INT</code> 是中断的缩写，<code>21H</code> 是DOS中断的编号。当这条指令执行时，CPU会暂停当前程序的执行，转而执行与<code>21H</code> 中断号相关联的中断处理程序，即DOS的内部功能。在这个例子中，由于<code>AH</code> 寄存器的值为<code>9</code>，DOS会执行显示字符串的功能，字符串的地址则通过<code>DX</code> 寄存器提供。</li>
<li><code>RET</code> 返回到DOS。</li>
<li><code>END START</code> 指示程序结束。</li>
</ul>
<ol start="2">
<li>指令性语句</li>
</ol>
<p>指令性语句与机器指令相对应，汇编程序可将它翻译成目标代码。语句格式为：</p>
<pre><code class="hljs">标号：指令助记符  操作数，操作数；注释
</code></pre>
<p><strong>标号</strong>——符号地址，后跟“:”，使用英文大小写字母阿拉伯数字和特殊字符，第一个非数字，≦31个<br><strong>助记符</strong>——与指令对应，不可省<br><strong>操作数</strong>——参加运算的数据，用常数、变量、标号、寄存器名或表达式<br><strong>注释</strong>——说明一指令或程序功能。可省略。用“ ;”隔离</p>
<ol start="3">
<li>伪指令语句</li>
</ol>
<p>伪指令语句无对应的机器指令，汇编程序汇编源程序时对伪指令进行处理，它可完成数据定义，存储区分配，段定义，段分配，指示程序结束等功能。语句格式为：</p>
<pre><code class="hljs">名字  伪指令指示符  操作数，操作数；注释
</code></pre>
<p><strong>名字</strong>——赋予伪指令的名称，名字后不允许带冒号“:”，可省略。名字常为变量名、段名、过程名、符号名等。<br><strong>指示符</strong>——汇编程序MASM规定的符号，各种定义语句后详述。<br><strong>操作数</strong>——按伪指令要求可有可无，操作数可以是常数、变量、字符串、表达式等。<br><strong>注释</strong>——功能和使用与指令性语句相同。</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-03-27_16-19-53.png" srcset="/img/loading.gif" lazyload alt="Clip_2024-03-27_16-19-53.png"></p>
<ol start="4">
<li>数据项</li>
</ol>
<p><strong>常数、变量和标号</strong>是三种基本数据项。</p>
<p>1．常数——二进制 (B)、八进制 (Q或O) 、十进制 (D) 、十六进制(H) 、 ASCll码字符串(用单引号‘abcd ’)。<br>2．变量<br>常指存放在M中的数值，程序运行中可修改。包含三个属性：<br>**段值(SEGMENT)**——变量所在段的段基址。<br>**段内偏移地址(OFFSET)**——变量地址与所在段首地址之间的地址偏移字节数。<br>**类型(TYPE)**——变量中每个元素包含的字节数,有字节变量(BYTE)，字变量(WORD)及双字变量(DWORD)等<br>3．标号<br>指令语句的地址的符号表示，可作为JMP指令和调用指令CALL的目标操作数，以确定程序转向的目标地址。包含三个属性：<br>**段值(SEGMENT)**——标号所在段的段基址。<br><strong>段内偏移地址(OFFSET</strong>)——标号地址与所在段的段首址之间的偏移地址字节数<br>**类型(TYPE)**——指转移指令中标号可转移的距离。近标号(NEAR)，远标号(FAR)。<br>    NEAR—指针长度2字节；	FAR —指针长度4字节</p>
<h2 id="MASM中的表达式"><a href="#MASM中的表达式" class="headerlink" title="MASM中的表达式"></a>MASM中的表达式</h2><p>表达式（运算对象、运算符）→汇编运算→结果作为语句中操作数</p>
<p>运算对象：常数、变量、标号<br>运算结果：常数或存储器地址（变量或标号）</p>
<center><b>8086汇编语言中的运算符</b></center>

<table>
<thead>
<tr>
<th>算术运算符</th>
<th>逻辑运算符</th>
<th>关系运算符</th>
<th>分析运算符</th>
<th>综合运算符</th>
</tr>
</thead>
<tbody><tr>
<td>+(加法)</td>
<td>AND(与)</td>
<td>EQ(相等)</td>
<td>SEG(求段基址)</td>
<td>PTR</td>
</tr>
<tr>
<td>-(减法)</td>
<td>OR(或)</td>
<td>NE(不相等)</td>
<td>OFFSET(求偏移量)</td>
<td>THIS</td>
</tr>
<tr>
<td>*(乘法)</td>
<td>XOR(异或)</td>
<td>LT(小于)</td>
<td>TYPE(求变量的类型)</td>
<td>SHORT</td>
</tr>
<tr>
<td>&#x2F;(除法)</td>
<td>NOT (非)</td>
<td>GT(大于)</td>
<td>SIZE(求字节数)</td>
<td>HIGH</td>
</tr>
<tr>
<td>MOD(取余)</td>
<td></td>
<td>LE(小于或等于)</td>
<td>LENGTH(求变量长)</td>
<td>LOW</td>
</tr>
<tr>
<td>SHL(左移)</td>
<td>逻辑左移</td>
<td>GE(大于或等于)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SHR(右移)</td>
<td>逻辑右移</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>所有的算术运算符均可以对数据进行运算，运算对象与运算结果都是整数。若对地址运算，通常是在标号上加／减某一个数字量，<strong>对地址乘是没有意义的</strong>。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>逻辑运算符是<strong>按位运算</strong>的，只能对常数进行运算，得到结果也是常数。<br>区分逻辑运算符、指令运算符<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240326223108.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>关系运算符所连接两操作数必为两数据或同一段内的两个存储单元的地址	<br>运算结果：真—0FFFFH，假—0	</p>
<pre><code class="hljs">类型/距离  PTR  变量或标号
</code></pre>
<p>将PTR左边的类型属性赋给右边的变量或标号。PTR本身并不分配存储单元，仅给已分配的存储单元赋予新的属性，这样可以保证运算时操作数类型的匹配，常与类型BYTE、WORD、NEAR、FAR等连用。 </p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运  算  符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>( ),[ ],&lt; &gt;,•,LENGTH,WIDTH,SIZE,MASK</td>
</tr>
<tr>
<td>2</td>
<td>PTR,OFFSET,SEG,TYPE,THIS,CS:,DS:,ES:,SS:</td>
</tr>
<tr>
<td>3</td>
<td>HIGHT,LOW</td>
</tr>
<tr>
<td>4</td>
<td>*, &#x2F; , MOD, SHL, SHR</td>
</tr>
<tr>
<td>5</td>
<td>+, -</td>
</tr>
<tr>
<td>6</td>
<td>EQ, NE, LT, LE, GT, GE</td>
</tr>
<tr>
<td>7</td>
<td>NOT</td>
</tr>
<tr>
<td>8</td>
<td>AND</td>
</tr>
<tr>
<td>9</td>
<td>OR, XOR</td>
</tr>
<tr>
<td>10</td>
<td>SHORT</td>
</tr>
</tbody></table>
<h2 id="伪指令语句"><a href="#伪指令语句" class="headerlink" title="伪指令语句"></a>伪指令语句</h2><p>一、数据定义语句<br>格式1：变量名  助记符  操作数，操作数，.. ;注释<br>格式2：变量名  助记符  n  DUP (操作数，操作数，..);注释<br>助记符——	DB	定义字节	 DW	定义字<br>        	DD	定义双字	 DQ	定义四字<br>         	DT	定义十字节<br>变量名——符号表示，可省略。作其后第一字节符号地址。<br>操作数——常数，字符串，变量，标号，表达式<br>n  DUP() ——n为整数，表示括号中操作数重复次数。</p>
<p>注意：<br>定义<strong>多字节字符串用DB</strong>，DW只允许包含两个字符。<br>操作数<strong>用“?”定义不确定值变量</strong>，以保留存储空间存放运算结果。新版Proteus支持“?”<br>用DW和DD可以将变量或标号逻辑地址存入存储器。当用DD来定义时，原变量或标号的偏移地址存入低位字中，原变量或标号的段基址存入高位字中。 </p>
<p>二、表达式赋值语句</p>
<ol>
<li>赋值语句EQU<br>格式：                           <strong>符号  EQU  表达式</strong></li>
</ol>
<p>用来给变量，标号，常数，指令，表达式等定义一个符号名，在同一个程序模块中不能重新定义。</p>
<p>PURGE语句可以解除对某一标号的赋值，使它在后面可以重新定义。</p>
<p>COUT  EQU CX    ；将COUT作为寄存器CX的同义名<br>PURGE COUNT      ;COUNT不再代替CX</p>
<ol start="2">
<li>等号语句   &#x3D;<br> 等号语句“&#x3D;”与EQU语句具有相同功能，区别仅在于EQU中左边的标号不允许重新定义，而用“&#x3D;”定义的语句允许重复定义。</li>
</ol>
<p>三、段定义、分配语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">.stack 100h   ;100h为堆栈空间的大小<br>.code<br>.startup  	;初始化指令<br></code></pre></td></tr></table></figure>

<p>四、过程定义语句<br>格式：过程名  PROC  属性<br>              ….<br>                 RET   N<br>           过程名  ENDP<br>定义一个过程，主程序可以用CALL指令调用它。<br><strong>过程名</strong>——不可缺省。过程名具有三种属性：</p>
<ul>
<li>(1) 段属性：为该过程所在段的段基址。</li>
<li>(2) 偏移地址属性：指该过程第一个字节与段首址之间距离字节。</li>
<li>(3) 距离属性：为NEAR或FAR。<br>PROC…ENDP——<strong>成对出现</strong>，不可缺省。<br>RET  N——过程内部的返回指令。RET后面的N为弹出值，可以缺省，表示从过程返回以后，<em>堆栈中应有N个字节的值作废(从栈顶开始)，N必须为<strong>正偶数</strong>。</em></li>
</ul>
<p>五、程序开始和结束语句</p>
<ol>
<li>NAME   程序名  		;为源程序目标模块赋名</li>
<li>TITLE   文本名       	 ;文本名赋予目标模块，作用通NAME</li>
<li>ORG  表达式		;设置地址指针，指定下个语句起始偏移地址</li>
<li>END  标号名		;标记汇编程序结束，位于源程序最后一行</li>
</ol>
<h2 id="DOS和BIOS调用"><a href="#DOS和BIOS调用" class="headerlink" title="DOS和BIOS调用"></a>DOS和BIOS调用</h2><table>
<thead>
<tr>
<th>软件中断指令</th>
<th>功  能</th>
</tr>
</thead>
<tbody><tr>
<td>INT 20H</td>
<td>程序正常退出</td>
</tr>
<tr>
<td>INT 21H</td>
<td>系统功能调用</td>
</tr>
<tr>
<td>INT 22H</td>
<td>结束退出</td>
</tr>
<tr>
<td>INT 23H</td>
<td>Ctrl+Break处理</td>
</tr>
<tr>
<td>INT 24H</td>
<td>出错退出</td>
</tr>
<tr>
<td>INT 25H</td>
<td>读磁盘</td>
</tr>
<tr>
<td>INT 26H</td>
<td>写磁盘</td>
</tr>
<tr>
<td>INT 27H</td>
<td>驻留退出</td>
</tr>
<tr>
<td>DOS系统功能调用(INT 21H)分别实现设备管理、文件读写、文件管理和目录管理等功能。每个子程序对应一个功能号，所有的系统功能调用的格式是一致的，按下面4步进行：</td>
<td></td>
</tr>
<tr>
<td>(1) 系统功能号送到AH寄存器中</td>
<td></td>
</tr>
<tr>
<td>(2) 入口参数送到指定寄存器中</td>
<td></td>
</tr>
<tr>
<td>(3) 由INT 21H指令执行功能调用</td>
<td></td>
</tr>
<tr>
<td>(4) 根据出口参数分析功能调用执行情况</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>AH</th>
<th>功   能</th>
<th>入口参数</th>
<th>出口参数</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>显示一个字符，检测Ctrl-Break</td>
<td>DL&#x3D;字符</td>
<td>光标随字符移动</td>
</tr>
<tr>
<td>6</td>
<td>直接控制台I&#x2F;O，不检测Ctrl-Break</td>
<td>DL&#x3D;FF(输入)<br><br>DL&#x3D;字符(输出)</td>
<td>光标随字符移动</td>
</tr>
<tr>
<td>9</td>
<td>显示字符串</td>
<td>DS:DX&#x3D;串地址；’$’结束字符串</td>
<td>光标随字符移动</td>
</tr>
</tbody></table>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器基本原理"><a href="#存储器基本原理" class="headerlink" title="存储器基本原理"></a>存储器基本原理</h2><p>RAM：随机访问存储器</p>
<ul>
<li>SRAM：静态存储器(Static random access memory)</li>
<li>DRAM：动态存储器(Dynamic random access memory)<br>ROM：只读存储器(Read only memory)</li>
</ul>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a><strong>SRAM</strong></h3><ul>
<li>T1～T4构成双稳态触发器</li>
<li>数据读出时，X、Y译码线为高</li>
<li>数据写入时，I&#x2F;O数据准备好，然后X、Y译码线为高</li>
<li>特点：速度快、电路复杂<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112426.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><strong>引脚信号</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112618.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>ADD</li>
<li>地址信号，在芯片手册中通常表示为A0，A1，A2，…<br>$\overline{CS}$</li>
<li>芯片选择，低电平时表示该芯片被选中<br>$\overline{WE}$</li>
<li>写允许，<strong>低电平表示写操作，高电平表示读操作</strong><br>Dout</li>
<li>数据输出信号，在芯片手册中通常表示为D0，D1，D2，…<br>Din</li>
<li>数据输入信号，也表示为D0，D1，D2，…<br>$\overline{OE}&#x2F;\overline{G}$</li>
<li>数据输出允许信号<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240325112834.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<p>读周期：</p>
<ul>
<li>地址有效-&gt;$\overline{CS}$有效-&gt;数据输出-&gt;$\overline{CS}$ 复位-&gt;地址撤销<br>写周期：</li>
<li>地址有效-&gt;$\overline{CS},\overline{WE}$有效-&gt;数据有效-&gt;$\overline{CS},\overline{WE}$复位（数据输入）-&gt;地址撤销</li>
</ul>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a><strong>DRAM</strong></h3><p>动态RAM是以MOS管源极电容是否充有电荷来存储信息的，其基本单元由<strong>T管</strong>和<strong>寄生电容</strong>Cs组成。</p>
<p>由于只用一个MOS管，所以功耗很低，存储容量可做得很大。</p>
<p>电容通过MOS管的栅极和源极会缓慢放电而丢失信息，因此必须定时对电容充电——<strong>刷新</strong>。</p>
<p>ADD：地址信号，在芯片手册中通常表示为A0、A1、A2、…<br>$\overline{CS}$：芯片选择，低电平时表示该芯片被选中。<br>$\overline{WE}$ ：写允许，<strong>低电平表示写操作，高电平表示读操作</strong>。<br>Dout：数据输出信号，在芯片手册中通常表示为D0、D1、D2、…<br>Din：数据输入信号，也表示为D0、D1、D2、…。<br>OE：数据输出允许信号。<br>$\overline{RAS}$：行地址选通信号。<br>$\overline{CAS}$：列地址选通信号</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327100235.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>Intel2164内含<strong>64k</strong>地址单元，通过行、列两部分地址，只需8位地址线。</p>
<p><strong>无片选信号</strong>，行选通信号可认为是片选信号：先行8位、再列8位选通，可选中216&#x3D;64k存储单元。</p>
<p><strong>读周期:</strong><br>行地址有效-&gt;行地址选通-&gt;列地址有效-&gt;列地址选通-&gt;数据输出-&gt;行选通、列选通及地址撤销</p>
<p><strong>写周期:</strong><br>行地址有效-&gt;行地址选通-&gt;列地址、数据有效-&gt;列地址选通-&gt;数据输入-&gt;行选通、列选通及地址撤销</p>
<p><strong>刷新周期:</strong>(only $\overline{RAS}$ refresh)<br>刷新行地址有效-&gt;$\overline{RAS}$有效-&gt;刷新行地址和$\overline{RAS}$撤销</p>
<p><strong>刷新周期:</strong>($\overline{CAS}$ refresh before $\overline{RAS}$)<br>$\overline{CAS}$有效-&gt;$\overline{RAS}$有效-&gt;$\overline{CAS}$撤销-&gt;$\overline{RAS}$撤销</p>
<p><strong>刷新周期:</strong>(隐含式刷新)</p>
<p>（在访存周期中）$\overline{RAS}$撤销-&gt;$\overline{RAS}$有效</p>
<h3 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a><strong>EPROM</strong></h3><ul>
<li>可擦除可编程只读存储器</li>
<li>顶部开有一个圆形的石英窗口，用于紫外线透过擦除原有信息</li>
<li>一般使用专门的编程器（烧写器）进行编程</li>
<li>编程后，应该贴上不透光封条</li>
<li>出厂未编程前，每个基本存储单元都是信息1，<strong>编程就是将某些单元写入信息0</strong></li>
</ul>
<h3 id="EEPROM-E2PROM"><a href="#EEPROM-E2PROM" class="headerlink" title="EEPROM&#x2F;E2PROM"></a><strong>EEPROM&#x2F;E2PROM</strong></h3><ul>
<li>电可擦除可编程只读存储器</li>
<li>在系统中是电可擦除的，擦写的电压比读入电压要高，通常为12V，擦写速度在毫秒量级，但仍比普通的RAM慢很多</li>
<li>不同厂家的EEPROM时序会有不同，要选择相应的EEPROM才能与芯片配合</li>
</ul>
<h3 id="Flash存储器"><a href="#Flash存储器" class="headerlink" title="Flash存储器"></a><strong>Flash存储器</strong></h3><ul>
<li>由E2PROM技术演化而来，读写速度更快、容量更大、成本更低。</li>
<li>必须以块为单位而非以字节为单位进行信息更新</li>
<li>分为NOR型和NAND型</li>
<li>NOR型：速度快，适合存储程序代码，支持程序直接在Flash存储器中运行</li>
<li>NAND型：容量大，集成度高</li>
</ul>
<h2 id="存储器的连接"><a href="#存储器的连接" class="headerlink" title="存储器的连接"></a>存储器的连接</h2><ul>
<li><strong>地址总线</strong>的连接<ul>
<li>CPU的地址总线宽度与存储器相同</li>
<li>CPU的地址总线宽度大于存储器的地址总线宽度</li>
</ul>
</li>
<li><strong>数据总线</strong>的连接<ul>
<li>CPU的数据总线宽度与存储器相同</li>
<li>CPU的数据总线宽度大于存储器的数据总线宽度</li>
</ul>
</li>
<li><strong>控制总线</strong>的连接<ul>
<li>存储器译码</li>
</ul>
</li>
</ul>
<h3 id="存储器扩展方法"><a href="#存储器扩展方法" class="headerlink" title="存储器扩展方法"></a><strong>存储器扩展方法</strong></h3><ol>
<li><strong>位扩展</strong></li>
</ol>
<ul>
<li>芯片的地址线数：18</li>
<li>存储器的结构256kb×32</li>
<li>容量：1MB</li>
<li>CPU的有效地址位数：20位字节地址</li>
<li>每个芯片的地址范围相同<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327102518.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>A0、A1用于选择32位的哪个字节<br>$2^{18}&#x3D;2^8+2^{10}&#x3D;256*1kb$<br><strong>位扩展是让数据位数增加，但是存储单元的个数不变（地址线的条数不增加）</strong></li>
<li>芯片地址线全部并联且与地址总线相应的地址线相连接；</li>
<li>片选信号（CE (Chip Enable)）并联，接地址译码器的输出端（这里直接用CPU的M&#x2F;IO管脚）；</li>
<li>芯片的数据线分高低部分，分别与数据总线相应位连接（这里由于是1位扩展到8位所以不用分高低位）。</li>
</ul>
<ol start="2">
<li><strong>字扩展</strong><br>存储器芯片引脚数: 18<br>存储器结构：$256kB\times8$<br>CPU有效地址线数：21<br>每个芯片的地址范围不同</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327104020.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>此图中，$A_0\sim A_{17}$ 用来选择一个256K的芯片，$A_{20}\sim A_{18}$ 连接译码器，译码器接受地址线上的型号，并根据信号选择特定的内存芯片，所以能选择8个中的任意一个。</p>
<p>以下说明与图不对应，图A17-0, A20-A18用于片选，备注：A10-A0, A11-A12译码片选</p>
<p>字扩展是存储单元数的扩展，要<strong>增加地址线的条数</strong>，而与数据线无关<br>由2K的芯片构成8K的模块，需要四块；相应的，需要多出两根地址线来选择这四块芯片。所以芯片固有地址线并联到地址总线的相应地址线上（A10-A0），扩展地址线（A11-A12）接译码器的输入端产生译码器的输出，用来作为四个芯片的片选信号。芯片的读写控制信号连接总线上的存储器控制信号。</p>
<ol start="3">
<li><strong>字位扩展</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327104938.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="存储器译码方法"><a href="#存储器译码方法" class="headerlink" title="存储器译码方法"></a><strong>存储器译码方法</strong></h3><ul>
<li><p><strong>全译码</strong></p>
<ul>
<li>所有CPU高位地址线均参与对存储单元的译码寻址</li>
<li>低位地址线对芯片内各存储单元的译码寻址：<strong>片内译码</strong></li>
<li>高位地址线对存储芯片的译码寻址：<strong>片选译码</strong></li>
<li>每个存储单元的地址都是唯一的：不存在地址重复</li>
</ul>
</li>
<li><p><strong>部分译码</strong></p>
<ul>
<li>部分高位地址线参与对存储单元的译码寻址</li>
<li>存在地址段内容重叠：<strong>每个单元有多个地址</strong></li>
</ul>
</li>
<li><p><strong>字选择</strong></p>
<ul>
<li>以字为单位访问存储器</li>
<li>位数等于存储器的字长</li>
<li>低位地址不需与存储器相连</li>
</ul>
</li>
<li><p>**** 字节选择</p>
<ul>
<li>可以字节为单位访问存储器</li>
<li>低位地址用于选择字节</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240327164505.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="8086CPU的存储器扩展"><a href="#8086CPU的存储器扩展" class="headerlink" title="8086CPU的存储器扩展"></a>8086CPU的存储器扩展</h2><p>连接部分主要由三个部分组成:<br>1.地址线  2.数据线 3.控制线</p>
<p>连接中需要考虑的问题:</p>
<ul>
<li>CPU总线的负载能力</li>
<li>CPU的时序和存储器存取速度之间的配合</li>
<li>存储器的地址分配和片选</li>
<li>控制信号的连接</li>
</ul>
<h3 id="线性选择方式"><a href="#线性选择方式" class="headerlink" title="线性选择方式"></a><strong>线性选择方式</strong></h3><p>只有存储芯片的片选信号CS有效，才能对芯片进行操作<br>连接方式：</p>
<ul>
<li>地址总线低13位与存储芯片地址线相连</li>
<li>CS端与某一位高位地址线（A13）相连</li>
<li>1＃芯片地址：0000～1FFFH、4000 ～5FFFH、……</li>
<li>2＃芯片地址：2000～3FFFH、6000 ～7FFFH、……<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-03-27_21-15-53.png" srcset="/img/loading.gif" lazyload alt="Clip_2024-03-27_21-15-53.png"></li>
</ul>
<h3 id="全译码"><a href="#全译码" class="headerlink" title="全译码"></a><strong>全译码</strong></h3><ul>
<li>所有的系统地址线均参与对存储单元的译码寻址</li>
<li>包括低位地址线对芯片内各存储单元的译码寻址（片内译码），高位地址线对存储芯片的译码寻址（片选译码）</li>
<li>采用全译码，每个存储单元的地址都是唯一的，不存在地址重复</li>
<li>译码电路可能比较复杂、连线也较多</li>
<li>常用译码器：74LS139、74LS138、74LS154</li>
</ul>
<p><strong>片选端译码小结</strong></p>
<ul>
<li>存储芯片的片选控制端可被高位地址线单独选用或经译码而得</li>
<li>在系统中，与地址相关的有：地址空间的选择（接系统的M&#x2F;$\overline{IO}$）和高位地址的译码选择（与系统的高位地址线相关联）</li>
<li>对存储芯片通过片选无效可关闭内部选通，以降低功耗</li>
<li>芯片$\overline{OE}$与系统的读命令线相连<ul>
<li>当芯片被选中、且读命令有效时，存储芯片将开放并驱动数据到总线</li>
</ul>
</li>
<li>芯片$\overline{WE}$与系统的写命令线相连<ul>
<li>当芯片被选中、且写命令有效时，允许总线数据写入存储芯片</li>
</ul>
</li>
</ul>
<h1 id="典型接口芯片原理和应用"><a href="#典型接口芯片原理和应用" class="headerlink" title="典型接口芯片原理和应用"></a>典型接口芯片原理和应用</h1><h2 id="简单I-O接口电路及其应用"><a href="#简单I-O接口电路及其应用" class="headerlink" title="简单I&#x2F;O接口电路及其应用"></a>简单I&#x2F;O接口电路及其应用</h2><h3 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a><strong>接口概述</strong></h3><ul>
<li><p>接口的功能</p>
<ul>
<li>设置数据缓冲器以解决两者速度差异所带来的不协调问题</li>
<li>设置信号电平转换电路</li>
<li>设置信息转换逻辑以满足对各自格式的要求</li>
<li>设置时序控制电路来同步CPU和外设的工作</li>
<li><strong>提供地址译码电路</strong>，使CPU在同一时刻只能选中某一个I&#x2F;O端口</li>
</ul>
</li>
<li><p>各种接口电路</p>
<ul>
<li>缓冲器(Buffer)和锁存器(Latch)；</li>
<li>可编程中断控制器8259A；</li>
<li>可编程计数器&#x2F;定时器8253；</li>
<li>可编程外围接口芯片8255A；</li>
<li>串行通信和可编程接口芯片8251A；</li>
<li>A&#x2F;D和D&#x2F;A转换芯片。</li>
</ul>
</li>
<li><p>把信息从外部设备送入 CPU 的接口称为<strong>输入接口</strong>，而把信息输出到外部设备的接口则称为<strong>输出接口</strong>。</p>
</li>
<li><p>I&#x2F;O接口电路是外设和计算机之间传送信息的交换部件，也称<strong>界面</strong>，它使两者之间很好地协调工作。外设一般都要通过接口电路才能和主机相连。<br>  CPU&lt;—&gt;接口&lt;—&gt;外设</p>
</li>
<li><p>在需要从外设<strong>输入数据</strong>时，通常外设的速度相对于 CPU 要慢得多，这意味着数据在外部总线上保持的时间相对较长，所以要求输入接口必须要具有对数据的控制能力，即要在外部数据准备好，CPU 可以读时才允许将数据送上系统数据总线。</p>
</li>
<li><p>大多数外设都具有<strong>数据保持能力</strong>（即 CPU 没有读取时，外设能够保持数据不变），通常可以仅用三态门缓冲器（简称<strong>三态门</strong>）作为输入接口。当三态门的控制端信号有效时，三态门导通，该外设就与数据总线连通，CPU 将外设准备好的数据读入；当控制端信号无效时，三态门断开，该外设就从数据总线脱离，数据总线又可用于其他信息的传送。</p>
</li>
<li><p>对没有数据保持能力的外设，可在外设与接口之间增加一个锁存器，用外设提供的数据准备好信号把数据保存到锁存器中。</p>
</li>
<li><p>在<strong>数据输出</strong>时，同样应考虑外设与 CPU 速度的配合问题。要使数据能正确写入外设，CPU 输出的数据一定要能够保持一段时间。一般 CPU 送到总线上的数据只能保持几个微秒甚至更短的时间。相对于慢速的外设，数据在总线上几乎是一闪而逝。因此，要求输出接口必须要具有数据的锁存能力，这通常是由锁存器来实现的。CPU 输出的数据通过总线锁存到锁存器中，并一直保持到被外设取走。</p>
</li>
<li><p>三态门缓冲器和锁存器的控制端一般与 I&#x2F;O 地址译码输出信号线相连，当 CPU 执行 I&#x2F;O 指令时，指令中指定的 I&#x2F;O 地址经译码后即可使控制信号有效，打开三态门（对外设读时）或将数据锁入锁存器（对外设写时）。</p>
</li>
</ul>
<h3 id="简单输入输出接口芯片"><a href="#简单输入输出接口芯片" class="headerlink" title="简单输入输出接口芯片"></a><strong>简单输入输出接口芯片</strong></h3><h4 id="三态缓冲器芯片-74LS244-74LS245"><a href="#三态缓冲器芯片-74LS244-74LS245" class="headerlink" title="三态缓冲器芯片 74LS244 &amp; 74LS245"></a><strong>三态缓冲器芯片 74LS244 &amp; 74LS245</strong></h4><ul>
<li>连接在总线上的缓冲器都具有三态输出能力。<ul>
<li><strong>使能</strong>→在使能控制端EN（或G）作用一个低电平脉冲→使内部的各缓冲单元[<strong>寄存器</strong>]接通→数据输出0或1的透明状态[数据被送上总线]。</li>
<li><strong>高阻态</strong>：当使能脉冲撤除后，它处于高阻态。这时，各缓冲单元像一个断开的开关，等于将它所连接的电路从总线脱开。</li>
</ul>
</li>
<li>除缓冲作用外，缓冲器还能提高总线的<strong>驱动能力</strong>。</li>
</ul>
<p><strong>74LS244</strong>——单向数据缓冲器<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-01_10-55-38.png" srcset="/img/loading.gif" lazyload alt="Clip_2024-04-01_10-55-38.png"></p>
<ul>
<li>8个三态缓冲单元，分成两组，分别由<strong>门控信号</strong>$\overline{1G}$和$\overline{2G}$控制。$\overline{1G}$和$\overline{2G}$为低电平时，数据传送；高电平时，输出高阻态。</li>
<li>单向缓冲器，只能从A端到Y端。</li>
</ul>
<p><strong>74LS245</strong>——双向数据缓冲器</p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-01_11-04-30.png" srcset="/img/loading.gif" lazyload alt="Clip_2024-04-01_11-04-30.png"></p>
<ul>
<li>8个双向、三态缓冲器。</li>
<li>门控信号输入端$\overline{G}$ 。</li>
<li>方向控制端DIR，高电平时，数据从A端传向B端；低电平时，从B端传向A端。</li>
</ul>
<p><strong>锁存器74LS373</strong></p>
<p>锁存器具有暂存数据的能力，能将数据锁住，在输出控制信号的作用下将数据传送出去。74LS373是一种常用的8D锁存器，它可以直接挂在总线上，并具有<strong>三态总线驱动能力</strong>。</p>
<ul>
<li>两个控制输入端：输入使能端G和允许输出端$\overline{OE}$。</li>
<li>$\overline{OE}$为低时：G为高时，D端数据到O端；G为低时，O端将是前面锁存的数据，不受D端的变化影响。</li>
<li>$\overline{OE}$为高时：输出将呈高阻态。</li>
</ul>
<table>
<thead>
<tr>
<th>$\overline{OE}$</th>
<th>G</th>
<th>D</th>
<th>O</th>
</tr>
</thead>
<tbody><tr>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>低</td>
<td>高</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>低</td>
<td>低</td>
<td>X</td>
<td>锁存</td>
</tr>
<tr>
<td>高</td>
<td>X</td>
<td>X</td>
<td>高阻态</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240401111412.png" srcset="/img/loading.gif" lazyload alt="image.png"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="I-O端口及其寻址方式"><a href="#I-O端口及其寻址方式" class="headerlink" title="I&#x2F;O端口及其寻址方式"></a><strong>I&#x2F;O端口及其寻址方式</strong></h3><ul>
<li><p>CPU与外设通信时，传送的信息主要包括数据信息、状态信息和控制信息。</p>
</li>
<li><p>这些信息分别进入不同的寄存器，通常将这些寄存器和它们的控制逻辑统称为I&#x2F;O端口（Port），CPU可对端口中的信息直接进行读写。<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240401112453.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>数据端口</strong>（Data Port）用来存放CPU与外设之间交换的数据，长度一般为1-2个字节，主要起缓冲作用。</p>
</li>
<li><p><strong>状态端口</strong>（Status Port）用来<strong>指示外设的当前状态</strong>。每种状态用<strong>1</strong>位表示，由CPU读取。几种最常用的状态位有：</p>
<ul>
<li>准备就绪位(Ready)<ul>
<li>输入端口：1：数据寄存器已准备好数据，等待CPU读取，取走后清0。</li>
<li>输出端口：1：输出数据寄存器已空，可以接收下一个数据；新数据到达后，位清0。</li>
</ul>
</li>
<li>忙碌位(Busy)<br>  表明外设是否能接收数据。1：外设忙，暂时不允许CPU送新的数据过来。0：外设已空闲，允许CPU发送下一个数据。</li>
<li>错误位(Error)<br>  1：指示在数据传送过程中出现错误。CPU进行相应的处理，如重新传送或中止操作等。</li>
</ul>
</li>
<li><p><strong>命令端口</strong>（Command Port）也称为控制端口（Control Port），用来存放CPU向接口发出的各种命令和控制字，以便控制接口和设备的动作。</p>
<ul>
<li>常见的命令信息有<strong>启动位、停止位、允许中断位</strong>等。</li>
<li>接口芯片不同，控制字的格式和内容是各不相同的，常见的控制字有<strong>方式控制字、操作命令字</strong>等。</li>
</ul>
</li>
<li><p>在微机系统中，CPU通过接口和外设交换数据时，只有输入（IN）和输出（OUT）两种指令，所以只能把状态信息和命令信息当作数据来传送，并且将状态信息作为输入数据，控制信息作为输出数据，于是三种信息都可以通过数据总线来传送了（三个不同端口的寄存器）。</p>
</li>
<li><p>I&#x2F;O端口的寻址方法</p>
<ul>
<li>存储器映像寻址方式（Memory Mapped I&#x2F;O）:<ul>
<li>将I&#x2F;O端口地址作为存储器地址，采用存储器访问指令进行操作</li>
</ul>
</li>
<li>I&#x2F;O单独编址方式：<ul>
<li>采用IN、OUT指令操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CPU与外设间的数据传送方式"><a href="#CPU与外设间的数据传送方式" class="headerlink" title="CPU与外设间的数据传送方式"></a><strong>CPU与外设间的数据传送方式</strong></h3><p>软件实现：程序控制方式、中断方式。<br>硬件实现：DMA方式。</p>
<ul>
<li>查询方式效率低。查询方式须反复查询外设的状态，查询等待过程会占去CPU的绝大部分时间，而真正用于数据交换的数据却很少，使CPU的利用率变得很低。为了提高CPU的利用率和进行实时数据处理，CPU常采用中断方式与外设交换数据。</li>
<li>中断方式效率高。采用中断方式，CPU执行主程序，只有当输入设备将数据准备好，或输出设备的数据缓冲器已空时，才向CPU发出中断请求。</li>
<li>CPU响应中断后，暂停执行当前的程序，转去执行管理外设的中断服务程序，用输入或输出指令在CPU和外设之间进行一次数据交换。</li>
<li>等输入&#x2F;输出操作完成之后，CPU又回去执行原来的程序。</li>
</ul>
<h4 id="程序控制方式-无条件方式（同步传送方式）"><a href="#程序控制方式-无条件方式（同步传送方式）" class="headerlink" title="程序控制方式-无条件方式（同步传送方式）"></a><strong>程序控制方式-无条件方式（同步传送方式）</strong></h4><ul>
<li>最简单的传送方式，主要用于对简单的外设进行操作，或者外设的定时是固定的或已知的场合；</li>
<li>程序可以不必检查外设的状态，而在需要进行I&#x2F;O操作时，直接执行I&#x2F;O指令。</li>
</ul>
<h4 id="程序控制方式-条件传送（查询式传送）"><a href="#程序控制方式-条件传送（查询式传送）" class="headerlink" title="程序控制方式-条件传送（查询式传送）"></a><strong>程序控制方式-条件传送（查询式传送）</strong></h4><ul>
<li>一般情况下，CPU在执行I&#x2F;O时，很难保证输入设备总是准备好数据，或是输出设备已经处在接收数据状态。<strong>CPU必须先确认外设已处于准备传送数据状态，才能进行传送。</strong></li>
<li><strong>确认过程</strong>：CPU必须先执行一条输入指令，从外设的状态口读取当前的状态。如果外设未准备好或处于忙碌状态，则程序要转回去反复执行读状态指令，不断检测外设的状态；直到外设准备就绪为止，然后CPU才可以进行正常的I&#x2F;O操作。</li>
</ul>
<p>查询式输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV BX,0；XOR BX, BX; 初始化地址指针BX<br>MOV CX,COUNT_1	;字节数<br>READ_S1:  IN AL,PORT_S1	;读入状态位<br>TEST AL,01H	;数据准备好否？<br>;TEST按位与 判断最低位是否为1，不为1则ZF=1<br>JZ READ_S1		;否，循环检测(Jump if zero) ZF=1时跳转<br>IN AL,PORT_IN 	;已准备好，读数据<br>MOV [BX],AL	;存到内存缓冲区<br>INC BX		;修改地址指针<br>LOOP READ_S1 	;未传送完，继续传送<br>     ...<br><br></code></pre></td></tr></table></figure>
<p>查询式输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV CX，COUNT_2	;传送的字节数<br>READ_S2: IN AL,PORT_S2	;读入状态位<br>TEST AL,02H			;bit 1是否为1,如果为1说明设备忙<br>JNZ READ_S2		;ZF=0 忙，循环检测<br>MOV AL,输出数据	;不忙<br>OUT PORT_OUT,AL;存到内存缓冲区<br>LOOP READ_S2	;未传送完，循环<br>	...		<br></code></pre></td></tr></table></figure>

<h4 id="中断方式-1"><a href="#中断方式-1" class="headerlink" title="中断方式"></a><strong>中断方式</strong></h4><ul>
<li><strong>查询方式效率低</strong>。查询方式须反复查询外设的状态，查询等待过程会占去CPU的绝大部分时间，而真正用于数据交换的数据却很少，使CPU的利用率变得很低。为了提高CPU的利用率和进行实时数据处理，CPU常采用中断方式与外设交换数据。</li>
<li><strong>中断方式效率高</strong>。采用中断方式，CPU执行主程序，只有当输入设备将数据准备好，或输出设备的数据缓冲器已空时，才向CPU发出中断请求。</li>
<li>CPU响应中断后，暂停执行当前的程序，转去执行管理外设的中断服务程序，用输入或输出指令在CPU和外设之间进行一次数据交换。</li>
<li>等输入输出操作完成之后，CPU又回去执行原来的程序。</li>
</ul>
<h2 id="可编程外围接口芯片8255A及其应用"><a href="#可编程外围接口芯片8255A及其应用" class="headerlink" title="可编程外围接口芯片8255A及其应用"></a>可编程外围接口芯片8255A及其应用</h2><h3 id="概述及结构"><a href="#概述及结构" class="headerlink" title="概述及结构"></a><strong>概述及结构</strong></h3><ul>
<li><strong>并行接口</strong>——一次可以同时传送一个数据的所有位</li>
<li><strong>并行接口的数据传送方向</strong>——一是单向传送(只作为输入口或输出口)，另一种是双向传送(既可作为输入口，也可作为输出口)</li>
<li><strong>并行接口的可编程性</strong><ul>
<li><strong>不可编程</strong>：简单(如锁存器或三态门)</li>
<li><strong>可编程</strong>：复杂，功能完善的并行接口中一般都包括输入&#x2F;输出数据寄存器、控制寄存器(存控制命令)、状态寄存器(存当前工作状态)和总线缓冲器等部件</li>
</ul>
</li>
<li>8255是Intel公司为80×86系列CPU配套的可编程并行接口芯片。通用性较强；使用灵活；典型的可编程并行接口。</li>
</ul>
<table>
<thead>
<tr>
<th>A1 A0</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>0    0</td>
<td>选择A口</td>
</tr>
<tr>
<td>0    1</td>
<td>选择B口</td>
</tr>
<tr>
<td>1     0</td>
<td>选择C口</td>
</tr>
<tr>
<td>1     1</td>
<td>选择控制寄存器</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110120.png" srcset="/img/loading.gif" lazyload alt="image.png"></td>
<td></td>
</tr>
<tr>
<td><strong>内部结构：</strong></td>
<td></td>
</tr>
<tr>
<td>C口：分为高4位、低4位两组</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110142.png" srcset="/img/loading.gif" lazyload alt="image.png"><br><strong>与系统总线的连接</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403110240.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="8255的工作方式"><a href="#8255的工作方式" class="headerlink" title="8255的工作方式"></a><strong>8255的工作方式</strong></h3><p>三种基本的工作方式：<br>    方式0：基本输入&#x2F;输出方式<br>    方式1：选通的输入&#x2F;输出方式<br>    方式2：双向传输方式 </p>
<p>A口：可以工作在方式0、方式1或方式2<br>B口、C口：只能工作于方式0或方式1。<br>3个端口的工作方式可通过软件编程来设定。 </p>
<h4 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a><strong>方式0</strong></h4><ul>
<li><strong>A口、C口的高4位，B口、C口的低4位</strong>可分别定义为输入或输出，它们互相独立，故共有16种不同的组合。</li>
<li>定义为输出：端口均<strong>有</strong>锁存数据的能力。</li>
<li>定义为输入：端口则<strong>无</strong>锁存能力。</li>
<li>在方式0下，C口有按位进行置位和复位的能力<br> <img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403111658.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<p>应用：</p>
<ul>
<li><strong>无条件传送方式</strong>：传送数据双方无需发控制信号给对方，也无需要查询对方状态。<ul>
<li>CPU只需直接执行输入&#x2F;输出指令便可将数据读入或写出。</li>
<li>A、B、C 3个口的全部<strong>24位</strong>都可以用做数据线。</li>
</ul>
</li>
<li><strong>查询工作方式</strong>：通信双方需互相了解对方的状态→通常将C口的高4位(或低4位)定义为输入，用来接收外设的状态信号；而将C口的另外4位定义为输出，用来产生控制信号。<ul>
<li>此时A、B口可用来传送数据。</li>
</ul>
</li>
</ul>
<h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a><strong>方式1</strong></h4><ul>
<li>也称为<strong>选通</strong>的输入&#x2F;输出方式</li>
<li>A、B、C 3个口被分为两组</li>
<li>A组：<ul>
<li>A口：数据口</li>
<li>C口高4位：用作A口输入&#x2F;输出操作的控制和同步信号</li>
</ul>
</li>
<li>B组：<ul>
<li>B口：数据口</li>
<li>C口低4位：用作B口输入&#x2F;输出操作的控制和同步信号</li>
</ul>
</li>
<li>A口和B口的输入和输出数据都被锁存<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240403111706.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>A B设定为输出口：<br>利用C口的6根线作为A口和B口的控制信号。控制信号线的安排是固定的，不允许改变：A口使用PC3、PC6和PC7，而B口用PC0、PC1和PC2。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407133236.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>A B设定为输入口：<br>利用C口的6根线作为A口和B口的控制信号。控制信号线的安排是固定的，不允许改变：A口使用PC3、PC4和PC5，而B口用PC0、PC1和PC2。 </p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/Clip_2024-04-07_13-34-25.png" srcset="/img/loading.gif" lazyload alt="Clip_2024-04-07_13-34-25.png"></p>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a><strong>方式2</strong></h4><ul>
<li>双向传输方式。只有A口可以工作在这种方式</li>
<li>外设能利用8位数据线与CPU进行双向通信，此时A口既作为输入口又作为输出口</li>
<li>利用C口的5根线来提供双向传输所需的控制信号</li>
<li>当A口工作于方式2时，B口可以工作在方式0或方式1，而C口剩下的3根线可作为输入&#x2F;输出线使用或用做B口方式1之下的控制信号线。<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407133942.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<h3 id="8255的控制字及状态字"><a href="#8255的控制字及状态字" class="headerlink" title="8255的控制字及状态字"></a><strong>8255的控制字及状态字</strong></h3><p>方式控制字<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240407134010.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>C口的位控制字：<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100322.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>方式1时的控制字：<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100340.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>方式2时的控制字：<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408100345.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>    可编程接口8255A端口地址是由其引脚决定的<br>    A1A0&#x3D;00,代表A端口地址<br>    A1A0&#x3D;01,代表B端口地址<br>    A1A0&#x3D;10,代表C端口地址<br>    A1A0&#x3D;11,代表控制字寄存器端口地址</p>
<h2 id="可编程计数器-定时器8253及其应用"><a href="#可编程计数器-定时器8253及其应用" class="headerlink" title="可编程计数器&#x2F;定时器8253及其应用"></a>可编程计数器&#x2F;定时器8253及其应用</h2><h3 id="定时信号的产生"><a href="#定时信号的产生" class="headerlink" title="定时信号的产生"></a><strong>定时信号的产生</strong></h3><ul>
<li>软件定时——设计一个延时子程序，子程序中全部指令执行时间的总和就是该子程序的延时时间。<ul>
<li>简单，易实现，但需了解延时子程序中每条指令执行时间；定时时间不精确；仅适用于延时时间较短、重复次数有限的场合；占用CPU大量的时间，降低CPU的利用率。</li>
</ul>
</li>
<li>硬件定时——利用专用的硬件定时&#x2F;计数器，在简单软件控制下产生准确的延时时间。<ul>
<li>通过软件确定定时&#x2F;计数器的工作方式、设置计数初值并启动计数器工作；当计数到给定值时，便自动产生定时信号；成本不高，程序简单，几乎不占用CPU资源；适合长时间、多次重复定时，也适合延时时间较短的场合。</li>
</ul>
</li>
</ul>
<p><strong>定时&#x2F;计数器的计数方式</strong></p>
<ul>
<li>加法计数器和减法计数器<ul>
<li>加法计数器是每有一个计数脉冲就加1，当加到预先设定的计数值时，产生一个定时信号</li>
<li>减法计数器是在送入计数初值后，每来一个计数脉冲就减1，减到0时产生一个定时信号输出</li>
</ul>
</li>
<li>可编程定时&#x2F;计数器8253就是一个<strong>减法计数器</strong>，它是Intel公司专为80X86系列配套开发的16位可编程定时&#x2F;计数器芯片。</li>
</ul>
<h3 id="8253的外部引脚及内部结构"><a href="#8253的外部引脚及内部结构" class="headerlink" title="8253的外部引脚及内部结构"></a><strong>8253的外部引脚及内部结构</strong></h3><ul>
<li>三通道的16位定时&#x2F;计数器</li>
<li>计数器的工作方式及计数常数分别由软件编程选择</li>
<li>可进行二进制或十进制计数或定时操作</li>
<li>最高计数频率为2 MHz</li>
<li>使用单电源+5 V供电</li>
<li>输入&#x2F;输出均与TTL电平兼容<br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408180355.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ul>
<table>
<thead>
<tr>
<th>$\overline{CS}$</th>
<th>$\overline{RD}$</th>
<th>$\overline{WR}$</th>
<th>A1 A0</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>00</td>
<td>写入计数器0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>01</td>
<td>写入计数器1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>10</td>
<td>写入计数器2</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>11</td>
<td>写入控制寄存器</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>00</td>
<td>读计数器0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>01</td>
<td>读计数器1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>读计数器2</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>11</td>
<td>无操作</td>
</tr>
<tr>
<td>1</td>
<td>×</td>
<td>×</td>
<td>××</td>
<td>禁止使用</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>××</td>
<td>无操作</td>
</tr>
<tr>
<td><strong>计数器</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>计数器0、1和2共<strong>3个相同的16位减1计数器</strong>；<strong>互相独立</strong>工作；每个计数器都包括一个16位的<strong>初值寄存器</strong>、一个<strong>计数执行单元</strong>和一个<strong>输出锁存器</strong></li>
<li>计数器工作过程：置入初值→计数执行单元对输入脉冲CLK进行减1计数直至0 →从OUT端输出一个信号；整个过程可以<strong>重复</strong>进行、可按<strong>二进制&#x2F;十进制</strong>计数；计数过程中，计数器还受到<strong>门控信号GATE</strong>的控制</li>
</ul>
<p><strong>控制寄存器</strong></p>
<ul>
<li>存放操作方式控制字，决定计数器的工作方式；控制字是在8253初始化时用输出指令写入控制寄存器的，<strong>寄存器只能写入，不能读出</strong><br><strong>数据总线缓冲器</strong></li>
<li>8位，双向，三态；8253和CPU数据总线间的接口<br><strong>读&#x2F;写控制逻辑</strong></li>
<li><strong>控制芯片的工作状态</strong>。选片有效时，读&#x2F;写控制逻辑从系统总线接收输入信号，经过逻辑组合，产生对各部分的控制信号；无效(高电平)时， 8253与总线断开</li>
</ul>
<p><strong>计数启动方法</strong></p>
<ul>
<li>软件启动——程序指令启动<ul>
<li>从CPU写入计数初值到计数结束，<strong>实际的CLK脉冲个数比编程写入的计数初值N要多一个</strong>，即N+1（不可避免）。（方式2、3 应该+1）</li>
</ul>
</li>
<li>硬件启动——由外部电路信号启动<ul>
<li>写入计数初值后并不启动计数，在<strong>门控信号GATE由低电平变高</strong>后，再经CLK信号的上升沿采样之后在该CLK的下降沿才开始计数。</li>
<li>GATE信号与CLK信号不一定同步，极端情况下从GATE变高到CLK采样之间的延时可能会经历一个CLK脉冲宽度，计数初值与实际的CLK脉冲个数间也会有一个时钟脉冲的误差。<pre class="mermaid">graph TD;
  A(CPU讲计数初值写入初值寄存器)-->B(将初值寄存器中内容送到计数器);
  B-->C(计数器开始减1计数);
  C-->D(减1到0时在OUT端输出一个信号);</pre>
<strong>计数方式</strong></li>
</ul>
</li>
<li>不自动重复的计数方式：计数器每启动一次只工作一个周期(即从初值减到0)</li>
<li>自动重复的计数方式：一旦计数启动，只要门控信号GATE保持高电平，计数过程就会自动周而复始地重复下去，这时OUT端可以产生连续的波形输出。</li>
<li>在自动重复计数方式下，达到稳定状态后，因启动造成的实际计数值和计数初值之间的误差就不再存在。</li>
</ul>
<h3 id="8253的工作方式"><a href="#8253的工作方式" class="headerlink" title="8253的工作方式"></a><strong>8253的工作方式</strong></h3><table>
<thead>
<tr>
<th>方式</th>
<th>启动计数</th>
<th>中止计数</th>
<th>自动重复</th>
<th>更新初值</th>
<th>输出波形</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>软件(写入初值)</td>
<td>GATE&#x3D;0</td>
<td>否</td>
<td>立即有效</td>
<td>延时时间可变的上跳沿</td>
</tr>
<tr>
<td>1</td>
<td>硬件(GATE正跳变)</td>
<td></td>
<td>否</td>
<td>下一轮有效</td>
<td>宽度为$N\times T_{CLK}$ 的单一负脉冲</td>
</tr>
<tr>
<td>2</td>
<td>软件(写入初值)<br><br>硬件(GATE正跳变)</td>
<td>GATE&#x3D;0</td>
<td>是</td>
<td>下一轮有效</td>
<td>周期为$N\times T_{CLK}$ 、宽度为$T_{CLK}$的连续负脉冲</td>
</tr>
<tr>
<td>3</td>
<td>软件(写入初值)<br><br>硬件(GATE正跳变)</td>
<td>GATE&#x3D;0</td>
<td>是</td>
<td>下半轮有效</td>
<td>周期为$N\times T_{CLK}$ 的连续方波</td>
</tr>
<tr>
<td>4</td>
<td>软件(写入初值)</td>
<td>GATE&#x3D;0</td>
<td>否</td>
<td>下一轮有效</td>
<td>宽度为$T_{CLK}$的单一负脉冲</td>
</tr>
<tr>
<td>5</td>
<td>硬件(GATE正跳变)</td>
<td></td>
<td>否</td>
<td>下一轮有效</td>
<td>宽度为$T_{CLK}$的单一负脉冲</td>
</tr>
</tbody></table>
<p><strong>方式0工作波形（计数结束中断方式）</strong></p>
<p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183743.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><strong>方式1工作波形（可重复触发的单稳态触发器）</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183830.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>在<strong>门控信号GATE由低电平变高</strong>后，再经CLK信号的上升沿采样之后在该CLK的下降沿才开始计数。</p>
</blockquote>
<p><strong>方式2工作波形（频率发生器）</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183906.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>当计数器减到零的前一个 CLK ，OUT 输出低电平，即OUT -&gt;0 ，输出一个宽度为一个 CLK 周期的负脉冲，并自动重新装入初始值，自动启动计数。<br>可以通过 GATE &#x3D; 0 暂停计数。</p>
</blockquote>
<p><strong>方式3工作波形（方波发生器）</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183930.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>计数器减到1&#x2F;2初值时，OUT输出一个宽度为 1 &#x2F; 2 CLK 周期的负脉冲，并自动重新装入初始值，自动启动计数。<br>可以通过 GATE &#x3D; 0 暂停计数。</p>
</blockquote>
<p><strong>方式4工作波形（软件触发选通）</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408183955.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>计数结束后输出一个CLK周期的低电平，其余为高电平，不能自动循环。</p>
</blockquote>
<p><strong>软件5工作波形（硬件触发选通）</strong><br><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408184021.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>波形特征同方式4，但重置初值和GATE上升沿之后可重新计时</p>
</blockquote>
<h3 id="8253的控制字"><a href="#8253的控制字" class="headerlink" title="8253的控制字"></a><strong>8253的控制字</strong></h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408190449.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>$RW_1$ $RW_2$<br>01 写入低8位时，高8位自动为零。<br>10 写入高8位时，低8位自动为零。</p>
<p><strong>8253初始化</strong></p>
<ul>
<li>写入方式控制字<ul>
<li>三个通道用的控制字端口地址是相同的</li>
<li>三个控制字写入后存入通道对应的寄存器中</li>
</ul>
</li>
<li>写入计数初始值</li>
<li>读计数值（计时）<ul>
<li>以普通对计数器端口读的方法取得当前计数值</li>
<li>锁存计数器的当前计数值</li>
</ul>
</li>
</ul>
<h2 id="串口通信和可编程接口芯片8251A"><a href="#串口通信和可编程接口芯片8251A" class="headerlink" title="串口通信和可编程接口芯片8251A"></a>串口通信和可编程接口芯片8251A</h2><h3 id="串行通信基本概念"><a href="#串行通信基本概念" class="headerlink" title="串行通信基本概念"></a><strong>串行通信基本概念</strong></h3><p><img src="https://raw.githubusercontent.com/Thinler/PhotosOfNotes/master/classnotes/20240408200326.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>DTE- Data Terminal Equipment，常常是计算机。</li>
<li>DCE- Data Communication Equipment，常常是MODEM，也可以是计算机。</li>
<li>串行接口 – 主要是8251A、16550、8250等IC，连接DTE和DCE。</li>
</ul>
<p><strong>数据传送的方向</strong></p>
<ul>
<li>单工(Simplex)——通信是单向的。</li>
<li>半双工(Half duplex)——半双工指A能发信号给B，B也能发信号给A，但这两个过程不能同时进行，A或B发送完后要切换到接受状态。典型例子就是对讲机。</li>
<li>全双工(Duplex)——在A给B发信号的同时，B也可以给A发信号。典型的例子就是打电话。</li>
</ul>
<p><strong>传输速率</strong></p>
<ul>
<li>波特率——单位时间传送的位数，单位bps(bit&#x2F;s) 。</li>
<li>波特率因子K——每BIT占用的时钟周期数。 K&#x3D;接收或发送时钟频率&#x2F;波特率,	可取1，16，32，64<br>  Exx: 一个异步串行发送器，发送具有8位数据位的字符，在系统中使用一个奇偶校验位和两个停止位。若每秒发送100个字符，则其波特率为多少 ？<br>  100×(1+8+1+2)&#x3D;1200 bps<br>  起始位 数据位 校验位 停止位</li>
</ul>
<p><strong>信号的调制与解调</strong></p>
<ul>
<li>数据通信传输的是数字信号，要求传送线的频带很宽，若传输带宽很窄，直接传输数字信号，信号就要发生畸变。 因此，需用调制器将<strong>数字信号转换成模拟信号</strong>，经传输后再用解调器将其<strong>转换成数字信号</strong>。</li>
<li>根据载波 $Asin(\omega t+\phi)$ 的三个参数：幅度、频率、相位，常用的调制技术：<strong>幅度调制</strong> Amplitude-Modulating (AM)、<strong>频移键控法</strong> Frequency-Shift Keying (FSK)</li>
</ul>
<p><strong>串行通信数据格式</strong></p>
<ul>
<li>在数据通信中，传输的对象是一系列的 0和1 ，这些 0、1 在不同的位置有不同的含义，这些含义都要事先约定好。</li>
<li>在通信中，两种最基本的串行通信方式：<strong>异步串行通信</strong>(不使用共同的时钟和同步信号)、<strong>同步串行通信</strong>(使用共同的时钟和同步信号) 。</li>
</ul>
<table>
<thead>
<tr>
<th>异步串行通信</th>
<th>同步串行通信</th>
</tr>
</thead>
<tbody><tr>
<td>双方使用各自的时钟</td>
<td>双方使用同一时钟</td>
</tr>
<tr>
<td>一帧以字符为单位(一个字符帧的长度取决于帧格式)</td>
<td>以数据块为单位(数据块长度可变)</td>
</tr>
<tr>
<td>传输效率低</td>
<td>效率高，速度快</td>
</tr>
<tr>
<td>应用于传输速率不高时，简单，应用较广</td>
<td>应用于大批量，高速率数据通信场合</td>
</tr>
</tbody></table>
<p><strong>串行通信的校验方法</strong></p>
<ul>
<li>串行通信主要适用于远距离通信，因而噪声和干扰较大，为了保证高效而无差错地传送数据，对传送的数据进行校验就成了串行通信中必不可少的重要环节。</li>
<li>常用的校验方法有：奇偶校验、循环冗余校验(CRC) 。</li>
<li>奇偶校验：主要用于对一个字符的传送过程进行校验；奇偶校验可以检查出一个字节中发生的单个错误；奇偶校验不能自动纠错，发现错误后需“重传”。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="print-no-link">#嵌入式</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>嵌入式系统与接口技术</div>
      <div>https://thinler.github.io/2024/02/23/学习笔记/嵌入式系统与接口技术/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Thinler</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git&amp;github%20%E9%99%8C%E7%94%9F%E6%93%8D%E4%BD%9C/" title="Git&amp;Github陌生操作">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git&amp;Github陌生操作</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ubuntu%E4%B8%8Bgit%20clone%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/" title="Ubuntu下git clone加速方法">
                        <span class="hidden-mobile">Ubuntu下git clone加速方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Thinler/github-comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
